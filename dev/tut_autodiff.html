<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Differentiable modeling ¬∑ UnderwaterAcoustics.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">UnderwaterAcoustics.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="uw_basic.html">Underwater acoustics</a></li><li><a class="tocitem" href="pm_basic.html">Propagation modeling toolkit</a></li><li><a class="tocitem" href="pm_envref.html">Environmental model reference</a></li><li><a class="tocitem" href="pm_api.html">Propagation modeling API</a></li></ul></li><li><span class="tocitem">Propagation models</span><ul><li><a class="tocitem" href="pm_pekeris.html">PekerisRayModel</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="tut_turing.html">Probabilistic modeling</a></li><li class="is-active"><a class="tocitem" href="tut_autodiff.html">Differentiable modeling</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement"><span>Problem statement</span></a></li><li><a class="tocitem" href="#Dataset"><span>Dataset</span></a></li><li><a class="tocitem" href="#Gradient-descent"><span>Gradient descent</span></a></li><li><a class="tocitem" href="#Impulse-response-estimation"><span>Impulse response estimation</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href="tut_autodiff.html">Differentiable modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tut_autodiff.html">Differentiable modeling</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/org-arl/UnderwaterAcoustics.jl/blob/master/docs/src/tut_autodiff.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Differentiable-modeling"><a class="docs-heading-anchor" href="#Differentiable-modeling">Differentiable modeling</a><a id="Differentiable-modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Differentiable-modeling" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This tutorial is adapted from the example presented in the UComms 2020 webinar talk &quot;<a href="https://www.facebook.com/watch/live/?v=2473971036238315">Underwater Acoustics in the age of differentiable and probabilistic programming</a>&quot;.</p></div></div><h2 id="Problem-statement"><a class="docs-heading-anchor" href="#Problem-statement">Problem statement</a><a id="Problem-statement-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-statement" title="Permalink"></a></h2><p>Let us consider a scenario where a drifting probe acoustically transmits its sensor data periodically to a static receiver. The initial position of the sensor is perfectly known, and so is the environment. But the path of the sensor as it drifts is not known, but we&#39;d like to get an estimate of it from the received acoustic signal. Due to the high data rate requirements, the receiver uses an equalization technique that requires an accurate estimate of the channel impulse response. We want to generate that using a propagation model and an accurate estimate of the location of the probe.</p><p>The environment is an isovelocity channel with a constant depth of 20 m and known seabed parameters (relative density <code>œÅ</code> = 1.5, relative soundspeed <code>c</code> = 1.2, and attenuation <code>Œ¥</code> = 0.001). The probe uses a 1-2 kHz band for data transmission, and includes 101 pilots at 10 Hz spacing to aid with channel estimation. The transmission loss can be accurately measured at those pilot frequencies, since the transmit source level is assumed to be known, but phase information is assumed to be unavailable at each pilot.</p><p><img src="images/tut_autodiff_1.png" alt/></p><h2 id="Dataset"><a class="docs-heading-anchor" href="#Dataset">Dataset</a><a id="Dataset-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset" title="Permalink"></a></h2><p>To illustrate the idea, we generate a 60-transmission dataset with a linearly drifting path for the transmitter. Since we have an range-independent isovelocity environment, we can use the <code>PekerisRayModel</code> (otherwise we could use the <code>RaySolver</code>):</p><pre><code class="language-julia hljs">using UnderwaterAcoustics
using DataFrames

function ùí¥(Œ∏)
  r, d, f, œÅ, c, Œ¥ = Œ∏
  env = UnderwaterEnvironment(seabed = RayleighReflectionCoef(œÅ, c, Œ¥))
  tx = AcousticSource(0.0, -5.0, f)
  rx = AcousticReceiver(r, -d)
  pm = PekerisRayModel(env, 7)
  transmissionloss(pm, tx, rx)
end

data = [(
    range=100.0 + 0.5t,
    depth=6.0 + 0.01t,
    pilots=[ùí¥([100.0 + 0.5t, 6.0 + 0.01t, f, 1.5, 1.2, 0.001]) for f ‚àà 1000.0:10.0:2000.0]
  ) for t ‚àà 0.0:1.0:59.0]
data = DataFrame(vec(data))</code></pre><h2 id="Gradient-descent"><a class="docs-heading-anchor" href="#Gradient-descent">Gradient descent</a><a id="Gradient-descent-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-descent" title="Permalink"></a></h2><p>In order to recover the drift path of the probe, we build a simple error model for the measured pilots. We initialize the model with the known starting location of the probe, and track the probe by minimizing the error through gradient descent.</p><p>Since our propagation model is differentiable, the gradient of the error can be automatically computed during the optimization using <a href="https://github.com/JuliaDiff/ForwardDiff.jl"><code>ForwardDiff.jl</code></a>.</p><pre><code class="language-julia hljs">using ForwardDiff

# channel model for pilots
pilots(r, d) = [
  ùí¥([r, d, f, 1.5, 1.2, 0.001]) for f ‚àà 1000.0:10.0:2000.0
]

# gradient descent optimization
function chparams(data)
  history = []
  Œ∏ = [100.0, 6.0]    # known initial location
  Œ∑ = [1e-4, 1e-6]    # learning rate
  for row ‚àà eachrow(data)
    err(Œ∏) = sum(abs2, pilots(Œ∏[1], Œ∏[2]) .- row.pilots)  # error model
    for i ‚àà 1:100      # iterations of simple gradient descent
      Œ∏ .-=  Œ∑ .* ForwardDiff.gradient(err, Œ∏)
    end
    push!(history, (range=Œ∏[1], depth=Œ∏[2]))
  end
  DataFrame(history)
end

p = chparams(data)</code></pre><p>Now that we have a path estimate, let&#39;s check it against the ground truth:</p><pre><code class="language-julia hljs">using Plots

plot(data.range, -data.depth; xlabel=&quot;Range (m)&quot;, ylabel=&quot;Depth (m)&quot;, label=&quot;Ground truth&quot;)
scatter!(p.range, -p.depth; label=&quot;Estimated&quot;)</code></pre><p><img src="images/tut_autodiff_2.png" alt/></p><p>We have a pretty good match!</p><h2 id="Impulse-response-estimation"><a class="docs-heading-anchor" href="#Impulse-response-estimation">Impulse response estimation</a><a id="Impulse-response-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Impulse-response-estimation" title="Permalink"></a></h2><p>Now we can generate the impulse response for each of the 60 received data packets:</p><pre><code class="language-julia hljs"># compute impulse response
function iresp(r, d)
  env = UnderwaterEnvironment(
    seabed = RayleighReflectionCoef(1.5, 1.2, 0.001)
  )
  tx = AcousticSource(0.0, -5.0, 1500.0)
  rx = AcousticReceiver(r, -d)
  pm = PekerisRayModel(env, 7)
  impulseresponse(arrivals(pm, tx, rx), 8000; reltime=true)[1:72]
end

ir = hcat([iresp(row.range, row.depth) for row ‚àà eachrow(p)]...)&#39;
heatmap(20*log10.(abs.(ir)); clim=(-60, -30), xlabel=&quot;Delay (samples)&quot;, ylabel=&quot;Transmission #&quot;, yflip=true)</code></pre><p><img src="images/tut_autodiff_3.png" alt/></p><p>We see the impulse response evolve over time as the probe drifts. This can then be used for channel equalization and to recover the transmitted data!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="tut_turing.html">¬´ Probabilistic modeling</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 12 April 2023 16:38">Wednesday 12 April 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
