[
  {
    "objectID": "pos.html",
    "href": "pos.html",
    "title": "Positions and units",
    "section": "",
    "text": "We often need 1D, 2D or 3D positions to describe the location of a source, receiver, or other object in the underwater environment. The canonical representation for positions is a named 3-tuple of coordinates of the form (x=0.0, y=0.0, z=0.0). We define the generic data type XYZ to represent such a named tuple:\nconst XYZ = NamedTuple{(:x,:y,:z)}\n\nIt is sometimes more convenient to represent positions in simpler forms, with just a single or two-coordinates. In most places where positions are expected, we automatically convert various input representations to a XYZ. This allows the user to specify scalars, tuples, or named tuples as input. For example, the AcousticReceiver(⋯) accepts receiver position as input:\n\nusing UnderwaterAcoustics\n\n# The following are all equivalent:\n@info AcousticReceiver((x=0, y=0, z=-10)).pos\n@info AcousticReceiver((x=0, z=-10)).pos\n@info AcousticReceiver((z=-10,)).pos\n@info AcousticReceiver((0, 0, -10)).pos\n@info AcousticReceiver((0, -10)).pos\n@info AcousticReceiver(-10).pos\n@info AcousticReceiver(0, 0, -10).pos\n@info AcousticReceiver(0, -10).pos\n\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n\n\nThe last two forms are only available in functions that accept no other positional arguments (other than position), and therefore do not cause any confusion as to the meaning of positional arguments.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Positions and units"
    ]
  },
  {
    "objectID": "pos.html#positions",
    "href": "pos.html#positions",
    "title": "Positions and units",
    "section": "",
    "text": "We often need 1D, 2D or 3D positions to describe the location of a source, receiver, or other object in the underwater environment. The canonical representation for positions is a named 3-tuple of coordinates of the form (x=0.0, y=0.0, z=0.0). We define the generic data type XYZ to represent such a named tuple:\nconst XYZ = NamedTuple{(:x,:y,:z)}\n\nIt is sometimes more convenient to represent positions in simpler forms, with just a single or two-coordinates. In most places where positions are expected, we automatically convert various input representations to a XYZ. This allows the user to specify scalars, tuples, or named tuples as input. For example, the AcousticReceiver(⋯) accepts receiver position as input:\n\nusing UnderwaterAcoustics\n\n# The following are all equivalent:\n@info AcousticReceiver((x=0, y=0, z=-10)).pos\n@info AcousticReceiver((x=0, z=-10)).pos\n@info AcousticReceiver((z=-10,)).pos\n@info AcousticReceiver((0, 0, -10)).pos\n@info AcousticReceiver((0, -10)).pos\n@info AcousticReceiver(-10).pos\n@info AcousticReceiver(0, 0, -10).pos\n@info AcousticReceiver(0, -10).pos\n\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n\n\nThe last two forms are only available in functions that accept no other positional arguments (other than position), and therefore do not cause any confusion as to the meaning of positional arguments.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Positions and units"
    ]
  },
  {
    "objectID": "pos.html#units",
    "href": "pos.html#units",
    "title": "Positions and units",
    "section": "Units",
    "text": "Units\nWe also support units though Unitful.jl. Internally, all quantities are represented as floating point numbers without explicit units, with standard units (mostly SI units) assumed implicitly. Input quantities are automatically converted to the implicit units as necessary. For example, positions can be specified with units:\n\n# The following are all equivalent:\n@info AcousticReceiver(1000, -10).pos\n@info AcousticReceiver(1000u\"m\", -10u\"m\").pos\n@info AcousticReceiver(1u\"km\", -10u\"m\").pos\n@info AcousticReceiver((1u\"km\", -10u\"m\")).pos\n@info AcousticReceiver((x=1u\"km\", z=-1000u\"cm\")).pos\n\n[ Info: (x = 1000.0, y = 0.0, z = -10.0)\n[ Info: (x = 1000.0, y = 0.0, z = -10.0)\n[ Info: (x = 1000.0, y = 0.0, z = -10.0)\n[ Info: (x = 1000.0, y = 0.0, z = -10.0)\n[ Info: (x = 1000.0, y = 0.0, z = -10.0)\n\n\nWe may also use units in other places:\n\n@show soundspeed(0u\"°C\");\n@show soundspeed(32u\"°F\");\n@show reflection_coef(10°, 1.2, 1.5);   # const ° is defined as u\"°\"\n@show absorption(10u\"kHz\");\n\nsoundspeed(0 * u\"°C\") = 1448.96\nsoundspeed(32 * u\"°F\") = 1448.96\nreflection_coef(10°, 1.2, 1.5) = 0.294789169055958 + 0.0im\nabsorption(10 * u\"kHz\") = 0.9253039111184715\n\n\nincluding environment descriptions:\n\nenv = UnderwaterEnvironment(\n  soundspeed = 1.5u\"km/s\",\n  temperature = 60u\"°F\",\n  salinity = 35u\"ppt\",\n  density = 1.025u\"g/cm^3\",\n  bathymetry = 100u\"m\"\n)\n\nUnderwaterEnvironment(\n  bathymetry = 100, \n  altimetry = 0.0, \n  temperature = 140//9, \n  salinity = 35, \n  soundspeed = 1500.0, \n  density = 1025.0, \n  seabed = RigidBoundary, \n  surface = PressureReleaseBoundary, \n)",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Positions and units"
    ]
  },
  {
    "objectID": "pos.html#extending",
    "href": "pos.html#extending",
    "title": "Positions and units",
    "section": "Extending",
    "text": "Extending\nWhile standard UnderwaterAcoustics.jl API functions automatically convert input values to the appropriate XYZ and units, you may wish to support these features in your own code when extending UnderwaterAcoustics.jl. To do so, you may use the unexported function xyz(⋯) to create a position from various different forms. You may also use the unexported in_units(⋯) function to convert input values to the appropriate units:\nusing UnderwaterAcoustics: XYZ, in_units\n\nfunction myfunction(pos, temperature)\n  pos = xyz(pos)\n  temperature = in_units(u\"°C\", temperature)\n  # ⋯\nend\n\nAPI reference\n\n\n\n\n\n\nxyz(pos)\nxyz(x, y, z)\nxyz(x, z)\nxyz(z)\nConvert a position to a named tuple with fields x, y, and z. If any of the coordinates is not provided, they are assumed to be zero. If the coordinates have units, they are converted to meters.\n\n\n\n\n\n\n\n\n\nin_units(u, x)\nGet the numerical value of x in units of u. If x is a Unitful.Quantity, it is converted to u. If x is a number, it is assumed to be in u and is returned as is.\nIf u is u\"dB\", the x may be specified as a number of a u\"dB\" quantity. In both cases, the numerical value of x in dB is returned.\n\nExamples:\njulia&gt; in_units(u\"Hz\", 10u\"kHz\")\n10000\n\njulia&gt; in_units(u\"m\", 10)\n10\n\njulia&gt; in_units(u\"m\", 1u\"cm\")\n1//100\n\njulia&gt; in_units(u\"dB\", 3)\n3\n\njulia&gt; in_units(u\"dB\", 3u\"dB\")\n3\n\n\n\n\n\n\n\n\n\n\ndistance(p1, p2)\nCompute distance between two positions.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Positions and units"
    ]
  },
  {
    "objectID": "quickstart.html",
    "href": "quickstart.html",
    "title": "Propagation & channel modeling",
    "section": "",
    "text": "Quickstart guide",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "quickstart.html#propagation-modeling",
    "href": "quickstart.html#propagation-modeling",
    "title": "Propagation & channel modeling",
    "section": "Propagation modeling",
    "text": "Propagation modeling\nLet’s get started:\n\nusing UnderwaterAcoustics\nusing Plots\n\n\nCreating an environmental description\nWe typically start with an environmental description:\n\nenv = UnderwaterEnvironment()\n\nUnderwaterEnvironment(\n  bathymetry = 100.0, \n  altimetry = 0.0, \n  temperature = 27.0, \n  salinity = 35.0, \n  soundspeed = 1538.9235842, \n  density = 1022.7198310217424, \n  seabed = RigidBoundary, \n  surface = PressureReleaseBoundary, \n)\n\n\nIf the defaults don’t suit our needs, we can customize the environment. For example, if we wanted an environment with 20 m water depth, sandy-clay seabed, and a smooth sound speed profile with 1500 m/s near the surface, 1490 m/s at 10 m depth, and 1520 m/s near the seabed, we could define:\n\nenv = UnderwaterEnvironment(\n  bathymetry = 20.0,\n  seabed = SandyClay,\n  soundspeed = SampledField([1500, 1490, 1520]; z=0:-10:-20, interp=:cubic)\n)\n\nUnderwaterEnvironment(\n  bathymetry = 20.0, \n  altimetry = 0.0, \n  temperature = 27.0, \n  salinity = 35.0, \n  soundspeed = SampledField(z-varying, 3 samples), \n  density = 1022.7198310217424, \n  seabed = FluidBoundary(ρ=1173.381, c=1504.9272, δ=0.00242), \n  surface = PressureReleaseBoundary, \n)\n\n\nIf we have Plots.jl installed, we can use plot recipes to plot the environment or the sound speed profile. For example:\n\nplot(env.soundspeed)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLet us construct a range-independent iso-velocity environment with water depth of 20 m:\n\nenv = UnderwaterEnvironment(bathymetry=20, seabed=SandyClay)\n\nUnderwaterEnvironment(\n  bathymetry = 20, \n  altimetry = 0.0, \n  temperature = 27.0, \n  salinity = 35.0, \n  soundspeed = 1538.9235842, \n  density = 1022.7198310217424, \n  seabed = FluidBoundary(ρ=1173.381, c=1504.9272, δ=0.00242), \n  surface = PressureReleaseBoundary, \n)\n\n\n\n\nSelecting a propagation model\nOnce we have an environment, we need to select a propagation model. Since we have a range-independent iso-velocity environment, we can use the PekerisRayTracer:\n\npm = PekerisRayTracer(env)\n\nPekerisRayTracer(h=20, max_bounces=3)\n\n\n\n\n\n\n\n\nTip\n\n\n\nWe can get a list of all available propagation models by calling models(), and a shortlist of all models compatible with a given environment by calling models(env).\n\n\n\n\nSetting up transmitters and receivers\nNext, we need a source and a receiver:\n\ntx = AcousticSource(0.0, -5.0, 1000.0)\n\nTX[1000.0 Hz, 0 dB](0.0, 0.0, -5.0)\n\n\n\nrx = AcousticReceiver(100.0, -10.0)\n\nRX(100.0, 0.0, -10.0)\n\n\nFor improved readability, positions can be specified as tuples or named tuples, and the API fully supports Unitful.jl:\n\ntx = AcousticSource((x=0u\"m\", z=-5u\"m\"), 1u\"kHz\")\n\nTX[1000 Hz, 0 dB](0.0, 0.0, -5.0)\n\n\n\nrx = AcousticReceiver(100u\"m\", -10u\"m\")\n\nRX(100.0, 0.0, -10.0)\n\n\n\n\n\n\n\n\nTip\n\n\n\n2-tuples are interpreted as (x, z) and 3-tuples as (x, y, z). The coordinate system has x and y axis in the horizontal plane, and z axis pointing upwards, with the nominal water surface being at 0 m. This means that all z coordinates in water are negative. If units are not specified, they are assumed to be S.I. units (meters for distances, Hz for frequency, etc).\n\n\nWe just defined an omnidirectional 1 kHz transmitter tx at a depth of 5 m at the origin, and an omnidirectional receiver rx at a range of 100 m and a depth of 10 m.\n\n\nRunning the model\nNow that we have an environment, a propagation model, a transmitter and a receiver, we can modeling. First, we ask for all ray arrivals (eigenrays) between the transmitter and receiver:\n\nrays = arrivals(pm, tx, rx)\n\n7-element Vector{UnderwaterAcoustics.RayArrival{Float64, Float64, Float64, Float64, Vector{@NamedTuple{x::Float64, y::Float64, z::Float64}}}}:\n ∠ -2.9°  0⤒  0⤓ ∠  2.9° |  65.06 ms | -40.0 dB ϕ   0.0°↝\n ∠  8.5°  1⤒  0⤓ ∠  8.5° |  65.71 ms | -40.1 dB ϕ 180.0°↝\n ∠-14.0°  0⤒  1⤓ ∠-14.0° |  66.98 ms | -62.6 dB ϕ 170.9°↝\n ∠ 19.3°  1⤒  1⤓ ∠-19.3° |  68.85 ms | -74.3 dB ϕ -23.4°↝\n ∠-24.2°  1⤒  1⤓ ∠ 24.2° |  71.26 ms | -80.4 dB ϕ-145.6°↝\n ∠ 28.8°  2⤒  1⤓ ∠ 28.8° |  74.16 ms | -73.5 dB ϕ  10.8°↝\n ∠-33.0°  1⤒  2⤓ ∠-33.0° |  77.50 ms | -100.7 dB ϕ-167.2°↝\n\n\nFor each eigenray, this shows us the launch angle, number of surface bounces, number of bottom bounces, arrival angle, travel time, transmission loss along that ray, and phase change. The last “↝” symbol indicates that the complete ray path is also available. We can plot the ray paths:\n\nplot(env; xlims=(-10,110))\nplot!(tx)\nplot!(rx)\nplot!(rays)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe red star is the transmitter and the blue circle is the receiver. The stronger eigenrays are shown in blue, while the weaker ones are shown in red.\nOften, we are interested in the arrival structure at a receiver. We generate an impulse response sampled at 48 kSa/s and plot it:\n\nplot(impulse_response(pm, tx, rx, 48000))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe first arrival is at 0 ms, as the impulse response is generated with timing relative to the first arrival. If we wanted timings relative to the transmission time, we can set keyword argument abstime to true:\n\nplot(impulse_response(pm, tx, rx, 48000; abstime=true))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also get the complex acoustic field or the transmission loss in dB:\n\nacoustic_field(pm, tx, rx)\n\n0.011324625487986332 + 0.013441467920062827im\n\n\n\ntransmission_loss(pm, tx, rx)\n\n35.101536894459066\n\n\nWe can also pass in arrays of receivers, if we want to compute transmission loss at many locations simultaneously. Some models are able to compute transmission loss on a Cartesian grid very efficiently. This is useful to plot transmission loss as a function of space.\nTo define a 1000×200 Cartesian grid with 0.1 m spacing and compute the transmission loss over the grid:\n\nrxs = AcousticReceiverGrid2D(1.0:0.1:100, -20:0.1:0)\nx = transmission_loss(pm, tx, rxs)\n\n991×201 Matrix{Float64}:\n 19.1283  19.2328  19.5428  19.8492  …   8.82646  11.1099  16.4209  87.1227\n 19.1329  19.2373  19.5471  19.8536      8.87496  11.1689  16.4855  87.123\n 19.1381  19.2424  19.552   19.8586      8.92702  11.2323  16.5549  87.1233\n 19.1442  19.2483  19.5577  19.8643      8.9824   11.2997  16.6288  87.1237\n 19.151   19.255   19.5641  19.8709      9.04085  11.3708  16.7068  87.124\n 19.1587  19.2626  19.5715  19.8784  …   9.10213  11.4454  16.7886  87.1244\n 19.1674  19.2712  19.5799  19.8869      9.16604  11.5232  16.8739  87.1248\n 19.1772  19.2809  19.5893  19.8965      9.23241  11.604   16.9625  87.1253\n 19.1882  19.2918  19.6     19.9073      9.30109  11.6875  17.0541  87.1258\n 19.2005  19.3039  19.6119  19.9194      9.37202  11.7737  17.1485  87.1263\n  ⋮                                  ⋱                               ⋮\n 37.3745  37.4387  37.4769  37.4921     57.8844   61.3578  67.2495  98.1624\n 37.4079  37.4741  37.5144  37.5317     57.9056   61.3788  67.2688  98.1837\n 37.4422  37.5104  37.5527  37.5722     57.9268   61.4001  67.2893  98.205\n 37.4774  37.5476  37.592   37.6136  …  57.9481   61.4217  67.3109  98.2263\n 37.5134  37.5857  37.6321  37.6558     57.9693   61.4435  67.3336  98.2477\n 37.5504  37.6247  37.6732  37.6989     57.9903   61.4655  67.3573  98.269\n 37.5882  37.6646  37.7151  37.7428     58.0112   61.4877  67.3819  98.2904\n 37.6269  37.7053  37.7578  37.7876     58.0319   61.5099  67.4075  98.3118\n 37.6665  37.7469  37.8014  37.8332  …  58.0524   61.5322  67.4338  98.3333\n\n\n\nplot(env; xlims=(0,100))\nplot!(rxs, x)",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "quickstart.html#channel-modeling",
    "href": "quickstart.html#channel-modeling",
    "title": "Propagation & channel modeling",
    "section": "Channel modeling",
    "text": "Channel modeling\n\nSimulating a transmission\nOnce we have a propagation model, we can setup a channel simulation. Let’s say we had a 10 kHz source transmitting at a source level of 170 dB re 1 µPa @ 1m and we wanted to run our simulations at 192 kSa/s:\n\ntx = AcousticSource((x=0u\"m\", z=-5u\"m\"), 10u\"kHz\"; spl=170)\nch = channel(pm, tx, rx, 192000)\n\nSampledPassbandChannel(1×1, 192000.0 Hz)\n\n\nThis channel accepts one input acoustic channel and yields one output acoustic channel. To transmit a signal through the channel, we create a windowed pulse using SignalAnalysis.jl and transmit() it through the channel ch:\n\nusing SignalAnalysis\n\nx = cw(10000, 0.001, 192000; window=(tukey, 0.5)) |&gt; real\ny = transmit(ch, x)\n\nplot(\n  plot(x; xlims=(0,5)),\n  plot(y; xlims=(0,5));\n  layout=(2,1)\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe received signal is scaled to be in µPa, assuming the source level of the transmitter was specified in dB re 1 µPa @ 1 m. We can clearly see the multipath arrivals in the received signal. Had we specified keyword argument abstime = true, we would have also seen the signal delayed by 65 ms.\n\n\nAdding noise\nWe can also simulate channels with noise. For example, if we wanted red Gaussian noise with standard deviation σ = 0.5 Pa, we can specify that when generating the channel:\n\nch = channel(pm, tx, rx, 192000; noise=RedGaussianNoise(0.5e6))\ny = transmit(ch, x)\n\nplot(\n  plot(x; xlims=(0,5)),\n  plot(y; xlims=(0,5));\n  layout=(2,1)\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can see the noise in the timeseries. We can see the 1/f² variation (red Gaussian noise) in the power spectral density superimposed on the 10 kHz peak from the transmitted pulse:\n\npsd(y)",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "basic.html",
    "href": "basic.html",
    "title": "Underwater acoustics",
    "section": "",
    "text": "API reference\n\n\n\n\n\n\nsoundspeed(temperature=27, salinity=35, depth=0; γ=0, cₐ=340, ρᵣ=1000)\nCompute sound speed in water in m/s, given:\n\nwater temperature in °C\nsalinity in ppt\ndepth in meters\nvoid fraction (γ) in bubbly water\nsound speed in gas (cₐ) if γ &gt; 0\nratio of density of water to gas (ρᵣ) if γ &gt; 0\n\nImplementation based on Mackenzie (1981), Wood (1964) and Buckingham (1997).\n\n\n\n\n\n\n\n\n\nabsorption(frequency, distance=1000, salinity=35, temperature=27, depth=0, pH=8.1)\nCompute volume acoustic absorption coefficient in water, given:\n\nfrequency in Hz\ndistance in meters\nsalinity in ppt\nwater temperature in °C\ndepth in meters\npH of water\n\nThe result is a unitless linear scale factor for sound pressure over the given distance. To get absorption in terms of dB / m, set distance = 1.0 and convert the result to decibels. For instance, at a frequency of 100 kHz:\njulia&gt; A = absorption(100e3, 1.0)\n0.9959084838594522\n\njulia&gt; α = -20log10(A)\n0.035611359656810865\nImplementation based on the Francois and Garrison (1982) model.\n\n\n\n\n\n\n\n\n\nwater_density(temperature=27, salinity=35)\nCompute density of water (kg/m³), given temperature in °C and salinity in ppt.\nImplementation based on Fofonoff (1985 - IES 80).\n\n\n\n\n\n\n\n\n\ndBperλ(x)\nCompute dimensionless absorption coefficient δ from dB/λ. Implementation based on APL-UW TR 9407 (1994), IV-9 equation (4).\n\n\n\n\n\n\n\n\n\nin_dBperλ(δ)\nCompute dB/λ from dimensionless absorption coefficient δ. Implementation based on APL-UW TR 9407 (1994), IV-9 equation (4).\n\n\n\n\n\n\n\n\n\nreflection_coef(θ, ρᵣ, cᵣ, δ=0.0)\nCompute complex reflection coefficient at a fluid-fluid boundary, given:\n\nangle of incidence θ (angle to the surface normal)\nrelative density of the reflecting medium to incidence medium ρᵣ\nrelative sound speed of the reflecting medium to incidence medium cᵣ\ndimensionless absorption coefficient δ\n\nImplementation based on Brekhovskikh & Lysanov. Dimensionless absorption coefficient based on APL-UW Technical Report 9407.\n\n\n\n\n\n\n\n\n\nsurface_reflection_coef(windspeed, frequency, θ)\nCompute surface reflection coefficient, given:\n\nwindspeed in m/s\nfrequency in Hz\nangle of incidence θ (angle to the surface normal)\n\nImplementation based on the APL-UW Technical Report 9407 II-21.\n\n\n\n\n\n\n\n\n\nbubble_resonance(radius, depth=0; γ=1.4, p₀=1.013e5, ρ=1022.72, g=9.80665)\nCompute resonance frequency of a freely oscillating has bubble in water, given:\n\nbubble radius in meters\ndepth of bubble in water in meters\ngas ratio of specific heats ‘γ’\natmospheric pressure ‘p₀’ in Pa\ndensity of water ‘ρ’ in kg/m³\nacceleration due to gravity ‘g’ in m/s²\n\nThis ignores surface-tension, thermal, viscous and acoustic damping effects, and the pressure-volume relationship is taken to be adiabatic. Implementation based on Medwin & Clay (1998).\n\n\n\n\n\n\n\n\n\ndoppler(speed, frequency)\ndoppler(speed, frequency, soundspeed)\nCompute Doppler frequency, given relative speed between transmitter and receiver in m/s. soundspeed is the nominal sound speed in water.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Underwater acoustics"
    ]
  },
  {
    "objectID": "api.html",
    "href": "api.html",
    "title": "Propagation & channel modeling",
    "section": "",
    "text": "API reference",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "api.html#environment-models",
    "href": "api.html#environment-models",
    "title": "Propagation & channel modeling",
    "section": "Environment models",
    "text": "Environment models\n\n\n\n\n\n\nUnderwaterEnvironment(; kwargs...)\nCreate a generic underwater environment with the given parameters. The following parameters are supported:\n\nbathymetry = bathymetry model\naltimetry = altimetry model\ntemperature = temperature model\nsalinity = salinity model\nsoundspeed = sound speed profile model\ndensity = density model\nseabed = seabed sediment model\nsurface = surface model\n\nAll parameters are optional and have default values. Parameters may be modified after construction by setting the corresponding property in the environment.\n\n\n\n\n\n\n\n\n\nis_range_dependent(env)\nReturn true if any quantity (e.g. sound speed, bathymetry, etc) in the environment env depends on the horizontal location, and false otherwise.\n\n\n\n\n\n\n\n\n\nis_isovelocity(env)\nReturn true if the sound speed in the environment env is a constant.\n\n\n\n\n\n\n\n\n\nenv_type(env)\nReturn the base number type for the environment. Typically, this is a Float64, but could differ if the environment was constructed using other number types.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "api.html#propagation-models",
    "href": "api.html#propagation-models",
    "title": "Propagation & channel modeling",
    "section": "Propagation models",
    "text": "Propagation models\n\n\n\n\n\n\nmodels()\nmodels(mtype::Type{&lt;:AbstractPropagationModel})\nReturn a list of all available propagation models. If mtype is specified, return only models of that type.\nmodels(env::UnderwaterEnvironment)\nReturn only models that are compatible with the environment env.\n\n\n\n\n\n\n\n\n\nPekerisRayTracer(env; max_bounces=3)\nA fast differentiable ray tracer that only supports iso-velocity constant depth environments. max_bounces is the number of surface/bottom bounces to consider in the ray tracing.\n\n\n\n\n\n\n\n\n\nPekerisModeSolver(env; ngrid=0)\nA fast differentiable mode propagation model that only supports iso-velocity constant depth environments.\nngrid is the number of grid points to use for modal root finding for fluid bottom environments. If ngrid is too small, the mode solver may miss some modes. If ngrid is too large, the mode solver may take a long time to converge. The default value of ngrid of 0 will use a heuristic to automatically determine the number of grid points to use.\n\n\n\n\n\n\n\n\n\nRayArrival\nType representing a single acoustic ray arrival.\nProperties:\n\nt / time: arrival time (s)\nϕ / phasor: complex amplitude\nns / surface_bounces: number of surface bounces\nnb / bottom_bounces: number of bottom bounces\nθₛ / launch_angle: launch angle at source (rad)\nθᵣ / arrival_angle: arrival angle at receiver (rad)\npath: ray path (optional, vector of 3-tuples or missing)\n\nThe properties are accessible with the short names for brevity, and longer more descriptive names where readability is desired or unicode symbols are undesired.\n\n\n\n\n\n\n\n\n\nModeArrival\nType representing a single acoustic mode arrival.\nProperties:\n\nm / mode: mode number\nkᵣ / hwavenumber: horizontal wavenumber (rad/m)\nψ(z) / mode_function: mode function\nv / group_velocity: group velocity (m/s)\n\nThe properties are accessible with the short names for brevity, and longer more descriptive names where readability is desired or unicode symbols are undesired.\n\n\n\n\n\n\n\n\n\narrivals(pm, tx, rx; paths=true)\nCompute the arrivals at the receiver rx due to the source tx using propagation model pm. Returns an array of arrivals.\nThe eigenray paths are typically included in the arrivals. However, if they are not needed, one may set paths=false to allow the propagation model to avoid computing them.\n\n\n\n\n\n\n\n\n\nacoustic_field(pm, tx, rxs)\nCompute the acoustic field at the receivers rxs due to the source tx using propagation model pm. If rxs denotes a single receiver, the result is a complex scalar. If rxs is an AbstractArray, the result is an array of complex numbers with the same shape as rxs. The amplitude of the field is related to the transmission loss, and the angle is related to the acoustic phase at the source frequency.\nacoustic_field(pm::PekerisRayTracer, tx, rxs; mode=:coherent)\nCompute the acoustic field at a receiver rxs due to a transmitter tx in the Pekeris waveguide. The field is computed incoherently if mode=:incoherent. Otherwise, the field is computed coherently.\nacoustic_field(pm::PekerisModeSolver, tx, rxs; mode=:coherent)\nCompute the acoustic field at a receiver rxs due to a transmitter tx in the Pekeris waveguide. The field can be computed incoherently if mode=:incoherent. Otherwise, the field is computed coherently.\n\n\n\n\n\n\n\n\n\ntransmission_loss(pm, tx, rxs)\nCompute the transmission loss from the source tx to the receivers rxs using propagation model pm. If rxs denotes a single receiver, the result is a scalar. If rxs is an AbstractArray, the result is an array of transmission losses (in dB) with the same shape as rxs.\n\n\n\n\n\n\n\n\n\nimpulse_response(pm, tx, rx, fs; abstime=false, ntaps=nothing)\nCompute the impulse response at the receiver rx due to the source tx using propagation model pm at the given sampling frequency fs. If abstime is true, the result is in absolute time from the start of transmission. Otherwise, the result is relative to the earliest arrival time of the signal at the receiver (possibly with some guard period to accommodate acausal response). ntaps specifies the number of taps in the impulse response. If not specified, the number of taps is chosen automatically based on the arrival times.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "api.html#channel-models-and-simulation",
    "href": "api.html#channel-models-and-simulation",
    "title": "Propagation & channel modeling",
    "section": "Channel models and simulation",
    "text": "Channel models and simulation\n\n\n\n\n\n\nchannel(pm, txs, rxs, fs; noise=nothing)\nCompute a channel model from the sources txs to the receivers rxs using propagation model pm. The result is a channel model with the same number of input channels as the number of sources and output channels as the number of receivers. The channel model accepts signals sampled at rate fs and returns signals sampled at the same rate.\nAn additive noise model may be optionally specified as noise. If specified, it is used to corrupt the received signals.\n\n\n\n\n\n\n\n\n\nBasebandReplayChannel(h, θ, fs, fc, step=1; noise=nothing)\nBasebandReplayChannel(h, fs, fc, step=1; noise=nothing)\nConstruct a baseband replay channel with impulse responses h and phase estimates θ. The phase estimates are optional. fs is the sampling frequency in Sa/s, fc is the carrier frequency in Hz, and step is the decimation rate for the time axis of h. The effective sampling frequency of the impulse responses is fs ÷ step impulse responses per second.\nAn additive noise model may be optionally specified as noise. If specified, it is used to corrupt the received signals.\nBasebandReplayChannel(filename; upsample=false, rxs=:, noise=nothing)\nLoad a baseband replay channel from a file.\nIf upsample is true, the impulse responses are upsampled to the delay axis sampling rate. This makes applying the channel faster but requires more memory. rxs controls which receivers to load from the file. By default, all receivers are loaded.\nAn additive noise model may be optionally specified as noise. If specified, it is used to corrupt the received signals.\nSupported formats:\n\n.mat (MATLAB) file in underwater acoustic channel repository (UACR) format. See https://github.com/uwa-channels/ for details.\n\n\n\n\n\n\n\n\n\n\ntransmit(ch, x; txs=:, rxs=:, abstime=false, noisy=true, fs=nothing)\nSimulate the transmission of passband signal x through the channel model ch. If txs is specified, it specifies the indices of the sources active in the simulation. The number of sources must match the number of channels in the input signal. If rxs is specified, it specifies the indices of the receivers active in the simulation. Returns the received signal at the specified (or all) receivers.\nfs specifies the sampling rate of the input signal. The output signal is sampled at the same rate. If fs is not specified but x is a SampledSignal, the sampling rate of x is used. Otherwise, the signal is assumed to be sampled at the channel’s sampling rate.\nIf abstime is true, the returned signals begin at the start of transmission. Otherwise, the result is relative to the earliest arrival time of the signal at any receiver. If noisy is true and the channel has a noise model associated with it, the received signal is corrupted by additive noise.\ntransmit(ch::BasebandReplayChannel, x; rxs=:, abstime=false, noisy=true, fs=nothing, start=nothing)\nSimulate the transmission of passband signal x through the channel model ch. If txs is specified, it specifies the indices of the sources active in the simulation. The number of sources must match the number of channels in the input signal. If rxs is specified, it specifies the indices of the receivers active in the simulation. Returns the received signal at the specified (or all) receivers.\nfs specifies the sampling rate of the input signal. The output signal is sampled at the same rate. If fs is not specified but x is a SampledSignal, the sampling rate of x is used. Otherwise, the signal is assumed to be sampled at the channel’s sampling rate.\nIf abstime is true, the returned signals begin at the start of transmission. Otherwise, the result is relative to the earliest arrival time of the signal at any receiver. If noisy is true and the channel has a noise model associated with it, the received signal is corrupted by additive noise.\nIf start is specified, it specifies the starting time index in the replay channel. If not specified, a random start time is chosen.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "api.html#boundary-conditions",
    "href": "api.html#boundary-conditions",
    "title": "Propagation & channel modeling",
    "section": "Boundary conditions",
    "text": "Boundary conditions\n\n\n\n\n\n\nreflection_coef(bc::AbstractAcousticBoundary, frequency, θ)\nreflection_coef(bc::AbstractAcousticBoundary, frequency, θ, ρ, c)\nCompute the complex reflection coefficient at a fluid-fluid boundary of type bc at incidence angle θ and frequency. The density and sound speed in the water are given by ρ and c, respectively.\n\n\n\n\n\n\n\n\n\nPressureReleaseBoundary\nPressure-release boundary condition.\n\n\n\n\n\n\n\n\n\nRigidBoundary\nRigid boundary condition.\n\n\n\n\n\n\n\n\n\nFluidBoundary(ρ, c, δ)\nCreate a fluid half-space boundary with density ρ, sound speed c, and dimensionless absorption coefficient δ.\n\n\n\n\n\n\n\n\n\nWindySurface(windspeed)\nReflection model for a water surface affected by wind. windspeed is given in m/s.\n\n\n\n\n\n\n\n\n\nPre-defined boundary conditions based on APL-UW Technical Report 9407:\n# sea surface boundary conditions\nconst SeaState0    = WindySurface(0.8)\nconst SeaState1    = WindySurface(2.6)\nconst SeaState2    = WindySurface(4.4)\nconst SeaState3    = WindySurface(6.9)\nconst SeaState4    = WindySurface(9.8)\nconst SeaState5    = WindySurface(12.6)\nconst SeaState6    = WindySurface(19.3)\nconst SeaState7    = WindySurface(26.5)\nconst SeaState8    = WindySurface(30.6)\nconst SeaState9    = WindySurface(32.9)\n# seabed boundary conditions\nconst Rock         = FluidBoundary(2557.5, 3820.0, 0.01374)\nconst Pebbles      = FluidBoundary(2557.5, 2750.4, 0.01374)\nconst SandyGravel  = FluidBoundary(2547.8, 2041.6, 0.01705)\nconst CoarseSand   = FluidBoundary(2282.3, 1911.1, 0.01638)\nconst MediumSand   = FluidBoundary(1886.8, 1799.5, 0.01624)\nconst FineSand     = FluidBoundary(1483.5, 1690.7, 0.01602)\nconst VeryFineSand = FluidBoundary(1297.8, 1613.4, 0.01875)\nconst ClayeySand   = FluidBoundary(1251.0, 1581.3, 0.02019)\nconst CoarseSilt   = FluidBoundary(1222.1, 1553.3, 0.02158)\nconst SandySilt    = FluidBoundary(1195.0, 1525.9, 0.01261)\nconst Silt         = FluidBoundary(1175.1, 1508.1, 0.00386)\nconst FineSilt     = FluidBoundary(1173.8, 1506.3, 0.00306)\nconst SandyClay    = FluidBoundary(1172.5, 1504.6, 0.00242)\nconst SiltyClay    = FluidBoundary(1171.2, 1501.7, 0.00163)\nconst Clay         = FluidBoundary(1169.8, 1498.4, 0.00148)",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "api.html#sources-and-receivers",
    "href": "api.html#sources-and-receivers",
    "title": "Propagation & channel modeling",
    "section": "Sources and receivers",
    "text": "Sources and receivers\n\n\n\n\n\n\nAcousticSource(pos, frequency; spl=0)\nAcousticSource(x, z, frequency; spl=0)\nAcousticSource(x, y, z, frequency; spl=0)\nAn source at location pos with nominal frequency and source level spl (dB re 1 µPa @ 1 m). The source is assumed to be omnidirectional and well approximated by a point source. While the source may have some bandwidth, the nominal frequency is used to estimate propagation effects such as absorption, reflection coefficients, etc.\nIf the location of the source is unknown, it may be specified as nothing. This is useful when the propagation model does not require the source location (e.g., data-driven models).\n\n\n\n\n\n\n\n\n\nAcousticReceiver(pos)\nAcousticReceiver(x, z)\nAcousticReceiver(x, y, z)\nReceiver at location pos.\n\n\n\n\n\n\n\n\n\nAcousticReceiverGrid2D(xrange, zrange)\nA 2D grid of receivers with the specified location ranges.\n\n\n\n\n\n\n\n\n\nAcousticReceiverGrid3D(xrange, yrange, zrange)\nA 3D grid of receivers with the specified location ranges.\n\n\n\n\n\n\n\n\n\nlocation(tx::AbstractAcousticSource)\nlocation(rx::AbstractAcousticReceiver)\nGet the location of the source or receiver.\n\n\n\n\n\n\n\n\n\nfrequency(tx::AbstractAcousticSource)\nGet the nominal frequency of an acoustic source.\n\n\n\n\n\n\n\n\n\nspl(tx::AbstractAcousticSource)\nGet the source level of an acoustic source.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "api.html#noise-models",
    "href": "api.html#noise-models",
    "title": "Propagation & channel modeling",
    "section": "Noise models",
    "text": "Noise models\n\n\n\n\n\n\nWhiteGaussianNoise(σ)\nWhiteGaussianNoise(psd, fs)\nCreate a white Gaussian ambient noise model with variance σ² µPa² or with power spectral density psd µPa²/Hz and bandwidth fs/2 Hz.\n\n\n\n\n\n\n\n\n\nRedGaussianNoise(σ)\nCreate an ambient noise model with variance σ² µPa² and 1/f² variation in power spectral density.\n\n\n\n\n\n\n\n\n\nrand([rng::AbstractRNG, ] noise::AbstractNoiseModel, nsamples; fs)\nrand([rng::AbstractRNG, ] noise::AbstractNoiseModel, nsamples, nchannels; fs)\nGenerate random noise samples from the noise model noise with the specified size nsamples (can be a 2-tuple for multichannel noise). The noise is returned as a signal sampled at fs. The optional rng argument specifies the random number generator to use.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "fields.html",
    "href": "fields.html",
    "title": "Range and depth dependence",
    "section": "",
    "text": "When describing underwater environments, we often need to work with quantities that vary with position. Some quantities are constant, while others may vary with depth, range, or 3D position (e.g. sound speed profile, bathymetry, etc). We introduce a consistent representation of fields to help formalize position-dependent quantities.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Range and depth dependence"
    ]
  },
  {
    "objectID": "fields.html#interface",
    "href": "fields.html#interface",
    "title": "Range and depth dependence",
    "section": "Interface",
    "text": "Interface\nFields that do not vary with position are considered constant, and are represented by scalars. If a field may vary only with depth, but not with horizontal position, it is considered DepthDependent. On the other hand, if it may vary with any positional coordinate, it is considered PositionDependent. Varying fields are represented by data types that are subtypes of the appropriate abstract type (DepthDependent or PositionDependent).\n\n\n\n\n\n\nDepthDependent\nQuantity that may vary with depth, but not with range (x or y coordinate).\n\n\n\n\n\n\n\n\n\nPositionDependent\nQuantity that may vary with depth and range (x, y and/or z coordinate).\n\n\n\nTo get the value of a field at a given position, we use the value function:\n\n\n\n\n\n\nvalue(q)\nvalue(q, pos)\nGet the value of the varying quantity q at the given position pos. pos may be specified as a (x, y, z) tuple, a (x, z) tuple, or a z value.\n\nExamples\nvalue(q)             # get value of a constant quantity\nvalue(q, -10)        # get value of a depth-dependent quantity at z=-10\nvalue(q, (1000,-10)) # get value of a position-dependent quantity at x=1000, z=-10\nvalue(q, (0,0,-10))  # get value of a position-dependent quantity at (0,0,-10)\n\n\n\n\nWe can also check if a field is constant or range-dependent:\n\n\n\n\n\n\nis_constant(q)\nReturn true if the quantity q is a constant, false if it could depend on position.\n\n\n\n\n\n\n\n\n\nis_range_dependent(q)\nReturn true if the quantity q may be range-dependent, false if it is guaranteed to not depend on x or y coordinate.\n\n\n\nFields that only vary with depth are neither constant nor range-dependent.\nSome propagation models require knowledge of the extreme values of a field. These can be obtained using the minimum and maximum functions:\n\n\n\n\n\n\nminimum(q)\nGet the minimum value of a field quantity q.\n\n\n\n\n\n\n\n\n\nmaximum(q)\nGet the maximum value of a field quantity q.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Range and depth dependence"
    ]
  },
  {
    "objectID": "fields.html#implementations",
    "href": "fields.html#implementations",
    "title": "Range and depth dependence",
    "section": "Implementations",
    "text": "Implementations\n\nConstants\nScalars are trivially constant fields:\n\nlet q = 1500\n  @show q\n  @show is_constant(q)\n  @show is_range_dependent(q)\n  @show value(q)\n  @show value(q, -10)\n  @show value(q, (1000, -10))\n  @show value(q, (0, 0, -10))\n  @show minimum(q)\n  @show maximum(q)\nend;\n\nq = 1500\nis_constant(q) = true\nis_range_dependent(q) = false\nvalue(q) = 1500\nvalue(q, -10) = 1500\nvalue(q, (1000, -10)) = 1500\nvalue(q, (0, 0, -10)) = 1500\nminimum(q) = 1500\nmaximum(q) = 1500\n\n\nThey can be used in environmental descriptions. For example, iso-velocity environments can be described using a constant sound speed:\nenv = UnderwaterEnvironment(soundspeed=1500)\n\n\nSampled fields\nPosition-dependent fields can be defined using data samples at a set of positions. Values at other positions are obtained by interpolation. The SampledField() function creates a sampled field from a set of data samples:\n\n\n\n\n\n\nSampledField(v; x)\nSampledField(v; z)\nSampledField(v; x, y)\nSampledField(v; x, z)\nSampledField(v; x, y, z)\nCreate a sampled field from a data v that may depend on position. For 1D fields, the x or z coordinate is required, and v is a vector. For 2D fields, the x and y coordinates or the x and z coordinates are required, and v is a matrix. For 3D fields, the x, y, and z coordinates are required, and v is a 3D array.\nKeyword argument interp is used to specify the interpolation method. :linear interpolation is supported for 1D, 2D and 3D fields. For 2D and 3D fields, the data must be sampled on a regular grid. For uniformly sampled 1D fields, :cubic interpolation is also supported.\n\n\n\nWe can understand how to use SampledField by looking at some examples. Let’s create an environment with a depth-dependent sound speed profile:\n\nenv = UnderwaterEnvironment(\n  soundspeed = SampledField([1500, 1520]; z=[0, -100])\n)\n\nlet q = env.soundspeed\n  @show q\n  @show is_constant(q)\n  @show is_range_dependent(q)\n  @show value(q, 0)\n  @show value(q, -50)\n  @show value(q, -100)\n  @show value(q, (1000, -50))\n  @show value(q, (0, 0, -50))\n  @show minimum(q)\n  @show maximum(q)\n  plot(q)\nend\n\nq = SampledField(z-varying, 2 samples)\nis_constant(q) = false\nis_range_dependent(q) = false\nvalue(q, 0) = 1500.0\nvalue(q, -50) = 1510.0\nvalue(q, -100) = 1520.0\nvalue(q, (1000, -50)) = 1510.0\nvalue(q, (0, 0, -50)) = 1510.0\nminimum(q) = 1500.0\nmaximum(q) = 1520.0\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe default interpolation method is linear, but we can use cubic interpolation by specifying interp=:cubic:\n\nplot(SampledField([1500, 1490, 1520]; z=0:-10:-20))\nplot!(SampledField([1500, 1490, 1520]; z=0:-10:-20, interp=:cubic))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnother example is a range-dependent bathymetry:\n\nenv = UnderwaterEnvironment(\n  bathymetry = SampledField([100, 110, 105, 110]; x=[0, 1000, 1500, 2000])\n)\n\nplot(env; xlims=(0,2000))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2D and 3D sampled fields can be created by specifying the x, y, and z coordinates. For example, a 2D field can be created using:\n\nlet q = SampledField([0.0 1.0; 1.0 2.0]; x=[0.0, 20.0], y=[0.0, 20.0])\n  @show q\n  @show is_constant(q)\n  @show is_range_dependent(q)\n  @show value(q, (10, 10, 0))\n  @show value(q, (10, 10, -10))\n  @show minimum(q)\n  @show maximum(q)\n  plot(q)\nend\n\nq = SampledField(xy-varying, 2×2 samples)\nis_constant(q) = false\nis_range_dependent(q) = true\nvalue(q, (10, 10, 0)) = 1.0\nvalue(q, (10, 10, -10)) = 1.0\nminimum(q) = 0.0\nmaximum(q) = 2.0\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCustom fields\nWe may define a custom field type by subtyping DepthDependent or PositionDependent. For example, we can define a Munk sound speed profile:\n\nstruct MunkSSP &lt;: UnderwaterAcoustics.DepthDependent end\n\nfunction (::MunkSSP)(pos)\n  ϵ = 0.00737\n  z̃ = 2.0 * (-pos.z - 1300.0) / 1300.0\n  1500.0 * (1.0 + ϵ * (z̃ - 1 + exp(-z̃)))\nend\n\nBase.minimum(::MunkSSP) = 1500.0    # 1.3 km depth\nBase.maximum(::MunkSSP) = 1654.0    # 11 km depth (maximum depth of the ocean)\n\nlet q = MunkSSP()\n  @show q\n  @show is_constant(q)\n  @show is_range_dependent(q)\n  @show value(q, -1300)\n  @show value(q, (100, 100, -1500))\n  @show minimum(q)\n  @show maximum(q)\n  plot(q, -11000:0; xlabel=\"Sound speed (m/s)\")\nend\n\nq = Main.Notebook.MunkSSP()\nis_constant(q) = false\nis_range_dependent(q) = false\nvalue(q, -1300) = 1500.0\nvalue(q, (100, 100, -1500)) = 1500.4735275294795\nminimum(q) = 1500.0\nmaximum(q) = 1654.0",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Range and depth dependence"
    ]
  },
  {
    "objectID": "kraken.html",
    "href": "kraken.html",
    "title": "Kraken",
    "section": "",
    "text": "Model\nAcousticsToolbox.Kraken\n\n\nDescription\nKraken and KrakenC normal mode models (wrapper)\n\n\nLanguage\nFortran\n\n\nAdvantages\nWell-established benchmark models\n\n\nLimitations\nNot differentiable, range-independent\nA good overview of the Bellhop model can be found at:",
    "crumbs": [
      "<b>Propagation models</b>",
      "Kraken"
    ]
  },
  {
    "objectID": "kraken.html#example",
    "href": "kraken.html#example",
    "title": "Kraken",
    "section": "Example",
    "text": "Example\nHere’s an example showing results for the PEKERIS test problem from the Kraken technical report:\n\nusing UnderwaterAcoustics\nusing AcousticsToolbox\nusing Plots\n\nenv = UnderwaterEnvironment(\n  bathymetry = 5000,\n  soundspeed = 1500,\n  density = 1000,\n  seabed = FluidBoundary(2000, 2000)\n)\npm = Kraken(env; chigh=2000)\n\ntx = AcousticSource(0, -500, 10)\nrx = AcousticReceiver(200000, -2500)\nmodes = arrivals(pm, tx, rx)[1:7]     # first 7 modes\n\n7-element Vector{UnderwaterAcoustics.ModeArrival{ComplexF32, UnderwaterAcoustics.SampledFieldZ{Interpolations.Extrapolation{ComplexF64, 1, Interpolations.GriddedInterpolation{ComplexF64, 1, Vector{ComplexF32}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Tuple{Vector{Float32}}}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Interpolations.Flat{Nothing}}, Vector{Float32}}, Float32}}:\n   mode 1: kᵣ = 0.041883 - 0.0im rad/m (1499.84 m/s)\n   mode 2: kᵣ = 0.04187 - 0.0im rad/m (1499.36 m/s)\n   mode 3: kᵣ = 0.041847 - 0.0im rad/m (1498.56 m/s)\n   mode 4: kᵣ = 0.041815 - 0.0im rad/m (1497.45 m/s)\n   mode 5: kᵣ = 0.041773 - 0.0im rad/m (1496.01 m/s)\n   mode 6: kᵣ = 0.041723 - 0.0im rad/m (1494.24 m/s)\n   mode 7: kᵣ = 0.041663 - 0.0im rad/m (1492.15 m/s)\n\n\n\n# plot the modes to a depth of 5 km\nplot(modes[1:7], 5000)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrxs = AcousticReceiverGrid2D(200000:10:220000, -2500)\nx = transmission_loss(pm, tx, rxs)\n\nplot(200:0.01:220, x; ylims=(70,110), yflip=true, legend=false,\n  xlabel=\"Range (km)\", ylabel=\"Transmission loss (dB)\")",
    "crumbs": [
      "<b>Propagation models</b>",
      "Kraken"
    ]
  },
  {
    "objectID": "kraken.html#notes",
    "href": "kraken.html#notes",
    "title": "Kraken",
    "section": "Notes",
    "text": "Notes\nThe Fortran Kraken propagation model requires that the transmitter is located at \\((x=0, y=0)\\) and all receivers are located in the right half-plane (i.e., \\(x&gt;0\\) and \\(y=0\\)). While this limitation can be worked around in the wrapper by a coordinate transformation, automatic transformation is not yet implemented.\nAdditionally, this wrapper does not yet support all the features of the original Fortran model. In particular, it does NOT support:\n\nRange-dependent environments (adiabatic or coupled mode approximations)\nN2-linear, analytic or quadratic interpolation for sound speed\nArbitrary reflection coefficients\nLayered seabed\nTwersky scattering\nInterfacial roughness\n\nReceivers on an irregular grid are supported, but not currently optimized for speed (by using the irregular grid option in the Fortran model).",
    "crumbs": [
      "<b>Propagation models</b>",
      "Kraken"
    ]
  },
  {
    "objectID": "pekeris-rays.html",
    "href": "pekeris-rays.html",
    "title": "PekerisRayTracer",
    "section": "",
    "text": "Model\nUnderwaterAcoustics.PekerisRayTracer\n\n\nDescription\nRay tracer for constant depth iso-velocity environments\n\n\nLanguage\nJulia\n\n\nAdvantages\nFast, differentiable\n\n\nLimitations\nIso-velocity, range-independent\n\n\nDifferentiability\nForwardDiff, Zygote, Mooncake, Enzyme\nImplementation based on mathematical description in:",
    "crumbs": [
      "<b>Propagation models</b>",
      "PekerisRayTracer"
    ]
  },
  {
    "objectID": "pekeris-rays.html#example",
    "href": "pekeris-rays.html#example",
    "title": "PekerisRayTracer",
    "section": "Example",
    "text": "Example\n\nusing UnderwaterAcoustics\nusing Plots\n\nenv = UnderwaterEnvironment(bathymetry=20, seabed=SandyClay)\npm = PekerisRayTracer(env)\n\ntx = AcousticSource(0, -5, 1000)\nrx = AcousticReceiver(100, -10)\nrays = arrivals(pm, tx, rx)\n\nplot(env; xlims=(-10, 110))\nplot!(tx)\nplot!(rx)\nplot!(rays)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrxs = AcousticReceiverGrid2D(1.0:0.1:100, -20:0.1:0)\nx = transmission_loss(pm, tx, rxs)\n\nplot(env; xlims=(0,100))\nplot!(rxs, x)",
    "crumbs": [
      "<b>Propagation models</b>",
      "PekerisRayTracer"
    ]
  },
  {
    "objectID": "tut2.html",
    "href": "tut2.html",
    "title": "Geoacoustic inversion with an acoustic profiler",
    "section": "",
    "text": "References\n\n\n\nThis tutorial is adapted from Example B presented in:\n\nMandar Chitre, “Differentiable Ocean Acoustic Propagation Modeling,” in OCEANS 2023 IEEE/MTS – Limerick, 5-8 June 2023.\n\nA version of this example was also presented in the UComms 2020 webinar:\n\nMandar Chitre, “Underwater Acoustics in the age of differentiable and probabilistic programming”, UComms 2020 webinar, 3 December 2020.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Geoacoustic inversion with an acoustic profiler"
    ]
  },
  {
    "objectID": "tut2.html#problem-statement",
    "href": "tut2.html#problem-statement",
    "title": "Geoacoustic inversion with an acoustic profiler",
    "section": "Problem statement",
    "text": "Problem statement\nWe consider a geoacoustic inversion problem where we have a static omnidirectional broadband acoustic source transmitting in a 5–7 kHz band, and a single omnidirectional receiver that records the signal at a fixed range. The receiver is able to profile the water column, and therefore makes transmission loss measurements at various depths. We wish to estimate seabed parameters from the transmission loss measurements. Do note that although we have acoustic measurements at various depths, they cannot be used for beamforming to separate out the bottom reflected arrival from other arrivals. We therefore only have transmission loss at each depth for our inversion.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Geoacoustic inversion with an acoustic profiler"
    ]
  },
  {
    "objectID": "tut2.html#dataset",
    "href": "tut2.html#dataset",
    "title": "Geoacoustic inversion with an acoustic profiler",
    "section": "Dataset",
    "text": "Dataset\nTo illustrate this idea, let us generate a synthetic dataset for a known set of seabed parameters (density ρ = 1500 kg/m³, relative soundspeed c = 1850 m/s, and attenuation δ = 0.001). The environment is assumed to be an iso-velocity and with a constant depth of 20 m. The source is at a depth of 5 m. The receiver is at a range of 100 m from the source, and makes measurements at depths from 1 to 19 m in steps of 1 m.\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSince we have an range-independent iso-velocity environment, we can use the PekerisRayTracer (otherwise we could use the RaySolver):\n\nusing UnderwaterAcoustics\nusing DataFrames\n\nfunction 𝒴(θ)\n  r, d, f, ρ, c, δ = θ\n  env = UnderwaterEnvironment(\n    bathymetry = 20.0,\n    seabed = FluidBoundary(ρ, c, δ)\n  )\n  tx = AcousticSource(0.0, -5.0, f)\n  rx = AcousticReceiver(r, -d)\n  pm = PekerisRayTracer(env)\n  transmission_loss(pm, tx, rx)\nend\n\ndata = DataFrame([\n  (depth=d, frequency=f, xloss=𝒴([100.0, d, f, 1500.0, 1850.0, 0.001]))\n  for d ∈ 1.0:1.0:19.0 for f ∈ 5000.0:100.0:7000.0\n])",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Geoacoustic inversion with an acoustic profiler"
    ]
  },
  {
    "objectID": "tut2.html#probabilistic-model",
    "href": "tut2.html#probabilistic-model",
    "title": "Geoacoustic inversion with an acoustic profiler",
    "section": "Probabilistic model",
    "text": "Probabilistic model\nWe use some very loose uniform priors for ρ, c and δ, and estimate the transmission loss using the same model 𝒴, as used in the data generation, but without information on the actual seabed parameters. We assume that the measurements of transmission loss are normally distributed around the modeled transmission loss, with a covariance of 0.5 dB.\nWe define the probabilistic model as a Turing.jl model:\n\nusing Turing\n\n# depths d, frequencies f, transmission loss measurements x\n@model function geoacoustic(d, f, x)\n  ρ ~ Uniform(1000.0, 2000.0)\n  c ~ Uniform(750.0, 2000.0)\n  δ ~ Uniform(0.0, 0.003)\n  μ = [𝒴([100.0, d[i], f[i], ρ, c, δ]) for i ∈ 1:length(d)]\n  x ~ MvNormal(μ, 0.5)\nend",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Geoacoustic inversion with an acoustic profiler"
    ]
  },
  {
    "objectID": "tut2.html#variational-inference",
    "href": "tut2.html#variational-inference",
    "title": "Geoacoustic inversion with an acoustic profiler",
    "section": "Variational inference",
    "text": "Variational inference\nOnce we have the model defined, we can run Bayesian inference on it. We could either use MCMC methods from Turing, or variational inference. Since our model is differentiable, we choose to use the automatic differentiation variational inference (ADVI):\n\n# this may take a minute or two to run...\nq = vi(\n  geoacoustic(data.depth, data.frequency, data.xloss),\n  ADVI(100, 1000)\n)\n\nThe returned q is a 3-dimensional posterior probability distribution over the parameters ρ, c and δ. We can estimate the mean of the distribution by drawing random variates and taking the sample mean:\n\nμ = mean(rand(q, 10000); dims=2)\n\n3×1 Matrix{Float64}:\n 1500.4884323728988\n 1850.0874858495117\n    0.001025261073074483\n\n\nWe see that the estimated parameter means for ρ, c and δ are quite close to the actual values used in generating the data.\nWe can also plot the conditional distributions of each parameter:\n\nusing StatsPlots\n\nplot(ρ -&gt; pdf(q, [ρ, μ[2], μ[3]]), 1300, 1700; xlabel=\"ρ\", legend=false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot(c -&gt; pdf(q, [μ[1], c, μ[3]]), 1650, 1950; xlabel=\"c\", legend=false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot(δ -&gt; pdf(q, [μ[1], μ[2], δ]), 0.0, 0.003; xlabel=\"δ\", legend=false)",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Geoacoustic inversion with an acoustic profiler"
    ]
  },
  {
    "objectID": "pekeris-modes.html",
    "href": "pekeris-modes.html",
    "title": "PekerisModeSolver",
    "section": "",
    "text": "Model\nUnderwaterAcoustics.PekerisModeSolver\n\n\nDescription\nNormal mode model for constant depth iso-velocity environments\n\n\nLanguage\nJulia\n\n\nAdvantages\nFast, differentiable (forward mode), multi-threaded\n\n\nLimitations\nIso-velocity, range-independent, pressure-release surface, fluid half-space seabed, no seabed absorption (no leaky modes)\n\n\nDifferentiability\nForwardDiff\nImplementation based on mathematical description in Theory below.",
    "crumbs": [
      "<b>Propagation models</b>",
      "PekerisModeSolver"
    ]
  },
  {
    "objectID": "pekeris-modes.html#example",
    "href": "pekeris-modes.html#example",
    "title": "PekerisModeSolver",
    "section": "Example",
    "text": "Example\n\nusing UnderwaterAcoustics\nusing Plots\n\nenv = UnderwaterEnvironment(\n  bathymetry = 5000,\n  soundspeed = 1500,\n  density = 1000,\n  seabed = FluidBoundary(2000, 2000)\n)\npm = PekerisModeSolver(env)\n\ntx = AcousticSource(0, -500, 10)\nrx = AcousticReceiver(200000, -2500)\nmodes = arrivals(pm, tx, rx)[1:7]      # first 7 modes\n\n7-element Vector{UnderwaterAcoustics.ModeArrival{ComplexF64, UnderwaterAcoustics.Mode{Float64}, Float64}}:\n   mode 1: kᵣ = 0.041883 + 0.0im rad/m (1499.84 m/s)\n   mode 2: kᵣ = 0.04187 + 0.0im rad/m (1499.36 m/s)\n   mode 3: kᵣ = 0.041847 + 0.0im rad/m (1498.56 m/s)\n   mode 4: kᵣ = 0.041815 + 0.0im rad/m (1497.45 m/s)\n   mode 5: kᵣ = 0.041773 + 0.0im rad/m (1496.01 m/s)\n   mode 6: kᵣ = 0.041723 + 0.0im rad/m (1494.24 m/s)\n   mode 7: kᵣ = 0.041663 + 0.0im rad/m (1492.15 m/s)\n\n\n\n# plot the modes to a depth of 5 km\nplot(modes[1:7], 5000)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrxs = AcousticReceiverGrid2D(200000:10:220000, -2500)\nx = transmission_loss(pm, tx, rxs)\n\nplot(200:0.01:220, x; ylims=(70,110), yflip=true, legend=false,\n  xlabel=\"Range (km)\", ylabel=\"Transmission loss (dB)\")",
    "crumbs": [
      "<b>Propagation models</b>",
      "PekerisModeSolver"
    ]
  },
  {
    "objectID": "pekeris-modes.html#sec-modal-theory",
    "href": "pekeris-modes.html#sec-modal-theory",
    "title": "PekerisModeSolver",
    "section": "Theory",
    "text": "Theory\nThe mathematical derivation of modal propagation in this section is based on:\n\nM. B. Porter, “The KRAKEN normal mode program”, Technical report NRL/MR/5120-92-6920, Naval Research Laboratory, 1992 (pdf).\n\n\nModal propagation\nThe acoustic wave equation is: \\[\n\\nabla^2p = \\frac{1}{c^2}\\frac{\\partial^2p}{\\partial t^2}.\n\\] In a Pekeris waveguide with a pressure-release surface and a pressure-release bottom (good approximation for a long range propagation problem, as it turns out), the boundary conditions in cylindrical coordinates are: \\[\n\\begin{align*}\np(r,0) &= 0 \\quad \\forall \\; r, \\\\\np(r,-D) &= 0.\n\\end{align*}\n\\] For a monochromatic source of frequency \\(f\\) Hz located at \\((0,-z_s)\\) boundary condition is: \\[\np(0,-z_s) = -A\\exp(-i\\omega t),\n\\] where \\(A\\) is the source amplitude, and \\(\\omega = 2\\pi f\\). Due to symmetry of the Pekeris waveguide, we have dropped the azimuthal coordinate.\nThe wave equation with these boundary conditions admits an approximate modal solution of the form: \\[\np(r,z,t) = \\frac{i}{4}\\sum_m\\psi_m(z_s)\\psi_m(z)H_0^{(1)}(k_mr)\\exp(-i\\omega t),\n\\] where \\(\\psi_m(z)\\) is the mode of order \\(m\\) and \\(H_0^{(1)}\\) is the Hankel function of the first kind and order 0, \\(k_m\\) is the horizontal wavenumber associated with mode. The mode \\(\\psi_m\\) is given by: \\[\n\\psi_m(z) = \\sqrt{\\frac{2}{D}}\\sin(\\gamma_m z),\n\\] where \\(\\gamma_m\\) is the vertical wavenumber associated with mode \\(m\\): \\[\n\\gamma_m = \\sqrt{k_0^2 - k_m^2},\n\\] for wavenumber \\(k_0 = \\omega/c\\).\n\\(\\gamma_m\\) is chosen to ensure boundary conditions are satisfied: \\[\n\\psi_m(0) = \\psi_m(D) = 0,\n\\] i.e., \\[\n\\gamma_m = m\\frac{\\pi}{D}.\n\\] If the bottom boundary condition is chosen for a rigid bottom: \\[\n\\begin{align*}\n& \\left.\\frac{d}{dz}\\psi_m(z)\\right|_{z=D} = 0, \\\\\n& \\therefore \\; \\gamma_m = \\left(m-\\frac{1}{2}\\right)\\frac{\\pi}{D}.\n\\end{align*}\n\\]\nSubstituting \\(\\psi_m\\) back, we have: \\[\np(r,z,t) = \\frac{i}{2D}\\sum_m\\sin(\\gamma_m z_s)\\sin(\\gamma_m z)H_0^{(1)}(k_mr)\\exp(-i\\omega t),\n\\] The transmission loss is then given by: \\[\n\\text{TL}(r,z) = -20\\log\\left| \\frac{p(r,z)}{p^0_{r=1}} \\right|,\n\\] where \\(p^0_{r=1}\\) is the pressure due to the source at 1 m from the acoustic center of the source: \\[\np^0_{r=1} = \\frac{\\exp(ik_0r)}{4\\pi r} = \\frac{\\exp(ik_0)}{4\\pi}.\n\\]\n\n\nAcousto-elastic boundary condition\nIf we use an acousto-elastic boundary condition for the seabed with sound speed \\(c_b\\) and density \\(\\rho_b\\), we have a boundary condition: \\[\n\\left.\\rho_b\\frac{d\\psi_m}{dz}\\right|_{z=D} = -\\rho\\sqrt{k_m^2 - k_b^2} \\; \\psi_m(r,D).\n\\] for \\(k_b = \\omega/c_b\\). Substituting \\(\\psi_m(r,z)\\): \\[\n\\rho_b\\gamma_m\\cos(\\gamma_m D) + \\rho\\sqrt{k_m^2 - k_b^2} \\; \\sin(\\gamma_m D) = 0.\n\\]\n\n\nGroup velocity\nThe group velocity of mode \\(m\\) is \\(d\\omega/dk_m\\): \\[\n\\begin{align*}\nk_m^2 &= k_0^2 - \\gamma_m^2 \\\\\n\\therefore \\; 2k_m\\frac{dk_m}{d\\omega} &= \\frac{2k_0}{c} - 2\\gamma_m\\frac{d\\gamma_m}{d\\omega} \\\\\n\\therefore \\; \\frac{dk_m}{d\\omega} &= \\frac{k_0}{c k_m} - \\frac{\\gamma_m}{k_m}\\frac{d\\gamma_m}{d\\omega}\n\\end{align*}\n\\] We can compute \\(\\frac{d\\gamma_m}{d\\omega}\\): \\[\n\\begin{align*}\n&\\rho_b\\gamma_m\\cos(\\gamma_m D) + \\rho\\sqrt{k_m^2 - k_b^2} \\; \\sin(\\gamma_m D) = 0 \\\\\n\\therefore \\quad &\\rho_b\\gamma_m\\cos(\\gamma_m D) + \\rho\\sqrt{k_0^2 - \\gamma_m^2 - k_b^2} \\; \\sin(\\gamma_m D) = 0 \\\\\n\\therefore \\quad &\\rho_b\\frac{d\\gamma_m}{d\\omega}\\cos(\\gamma_m D) - \\rho_b\\gamma_m\\sin(\\gamma_m D)D\\frac{d\\gamma_m}{d\\omega} + \\rho\\zeta\\cos(\\gamma_m D)D\\frac{d\\gamma_m}{d\\omega} \\\\\n&- \\frac{\\rho}{2\\zeta}\\sin(\\gamma_m D)\\left(\\frac{2k_0}{c} - 2\\gamma_m\\frac{d\\gamma_m}{d\\omega} - \\frac{2k_b}{c}\\right) = 0 \\\\\n\\therefore \\quad &\\left[\\rho_b\\cos(\\gamma_m D) - \\rho_bD\\gamma_m\\sin(\\gamma_m D) + \\rho D\\zeta\\cos(\\gamma_m D) - \\frac{\\rho\\gamma_m}{\\zeta}\\sin(\\gamma_m D)\\right]\\frac{d\\gamma_m}{d\\omega} \\\\\n&= -\\frac{\\rho k_0}{c\\zeta}\\sin(\\gamma_m D) - \\frac{\\rho k_b}{c\\zeta} \\; \\sin(\\gamma_m D) \\\\\n\\therefore \\quad &\\frac{d\\gamma_m}{d\\omega} = -\\frac{\\rho\\sin(\\gamma_m D)(k_0 + k_b)}{c\\zeta[\\rho_b\\cos(\\gamma_m D) - \\rho_bD\\gamma_m\\sin(\\gamma_m D) + \\rho D\\zeta\\cos(\\gamma_m D) - \\frac{\\rho\\gamma_m}{\\zeta}\\sin(\\gamma_m D)]} \\\\\n&= -\\frac{\\rho\\sin (\\gamma_m D)\\omega\\left(c^2-c_b^2\\right)}{c^2 c_b^2 \\gamma_m \\sin (\\gamma_m D) \\left(D\\text{$\\rho $b} \\zeta+\\rho \\right)+\\cos(\\gamma_m D) \\left(c^2 \\left(D\\rho\\omega ^2-c_b^2 \\text{$\\rho $b} \\zeta\\right)-c_b^2 D\\rho\\omega^2\\right)+c^2 c_b^2 D\\rho\\gamma_m^2\\cos(\\gamma_m D)}.\n\\end{align*}\n\\] where \\(\\zeta = \\sqrt{k_0^2 - \\gamma_m^2 - k_b^2}\\).",
    "crumbs": [
      "<b>Propagation models</b>",
      "PekerisModeSolver"
    ]
  },
  {
    "objectID": "tut1.html",
    "href": "tut1.html",
    "title": "Tracking a drifting transmitter",
    "section": "",
    "text": "References\n\n\n\nThis tutorial is adapted from Example A presented in:\n\nMandar Chitre, “Differentiable Ocean Acoustic Propagation Modeling,” in OCEANS 2023 IEEE/MTS – Limerick, 5-8 June 2023.\n\nA version of this example was also presented in the UComms 2020 webinar:\n\nMandar Chitre, “Underwater Acoustics in the age of differentiable and probabilistic programming”, UComms 2020 webinar, 3 December 2020.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Tracking a drifting transmitter"
    ]
  },
  {
    "objectID": "tut1.html#problem-statement",
    "href": "tut1.html#problem-statement",
    "title": "Tracking a drifting transmitter",
    "section": "Problem statement",
    "text": "Problem statement\nLet us consider a scenario where a drifting probe acoustically transmits its sensor data periodically to a static receiver. The initial position of the sensor is perfectly known, and so is the environment. But the path of the sensor as it drifts is not known, but we’d like to get an estimate of it from the received acoustic signal. Due to the high data rate requirements, the receiver uses an equalization technique that requires an accurate estimate of the channel impulse response. We want to generate that using a propagation model and an accurate estimate of the location of the probe.\nThe environment is an iso-velocity channel with a constant depth of 20 m and known seabed parameters (density ρ = 1500 kg/m³, sound speed c = 1850 m/s, and attenuation δ = 0.001). The probe uses a 1-2 kHz band for data transmission, and includes 101 pilots at 10 Hz spacing to aid with channel estimation. The transmission loss can be accurately measured at those pilot frequencies, since the transmit source level is assumed to be known, but phase information is assumed to be unavailable at each pilot.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Tracking a drifting transmitter"
    ]
  },
  {
    "objectID": "tut1.html#dataset",
    "href": "tut1.html#dataset",
    "title": "Tracking a drifting transmitter",
    "section": "Dataset",
    "text": "Dataset\nTo illustrate the idea, we generate a 60-transmission dataset with a linearly drifting path for the transmitter. Since we have an range-independent iso-velocity environment, we can use the PekerisRayTracer (otherwise we could use the RaySolver):\n\nusing UnderwaterAcoustics\nusing DataFrames\n\nfunction 𝒴((r, d, f, ρ, c, δ))\n  env = UnderwaterEnvironment(\n    bathymetry = 20.0,\n    seabed = FluidBoundary(ρ, c, δ)\n  )\n  tx = AcousticSource(r, -d, f)\n  rx = AcousticReceiver(0.0, -5.0)\n  pm = PekerisRayTracer(env)\n  transmission_loss(pm, tx, rx)\nend\n\ndata = DataFrame([(\n    range=100.0 + 0.5t,\n    depth=6.0 + 0.01t,\n    pilots=[𝒴([100.0 + 0.5t, 6.0 + 0.01t, f, 1500.0, 1850.0, 0.001]) for f ∈ 1000.0:10.0:2000.0]\n  ) for t ∈ 0.0:1.0:59.0])",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Tracking a drifting transmitter"
    ]
  },
  {
    "objectID": "tut1.html#gradient-descent",
    "href": "tut1.html#gradient-descent",
    "title": "Tracking a drifting transmitter",
    "section": "Gradient descent",
    "text": "Gradient descent\nIn order to recover the drift path of the probe, we build a simple error model for the measured pilots. We initialize the model with the known starting location of the probe, and track the probe by minimizing the error through gradient descent.\nSince our propagation model is differentiable, the gradient of the error can be automatically computed during the optimization using ForwardDiff.jl.\n\nusing ForwardDiff\n\n# channel model for pilots\npilots(r, d) = [𝒴([r, d, f, 1500.0, 1850.0, 0.001]) for f ∈ 1000.0:10.0:2000.0]\n\n# gradient descent optimization\nfunction chparams(data)\n  history = []\n  θ = [100.0, 6.0]    # known initial location\n  η = [1e-4, 1e-6]    # learning rate\n  for row ∈ eachrow(data)\n    err(θ) = sum(abs2, pilots(θ[1], θ[2]) .- row.pilots)  # error model\n    for i ∈ 1:100      # iterations of simple gradient descent\n      θ .-=  η .* ForwardDiff.gradient(err, θ)\n    end\n    push!(history, (range=θ[1], depth=θ[2]))\n  end\n  DataFrame(history)\nend\n\np = chparams(data)\n\nNow that we have a path estimate, let’s check it against the ground truth:\n\nusing Plots\n\nplot(data.range, -data.depth; linewidth=2, xlabel=\"Range (m)\", ylabel=\"Depth (m)\", label=\"Ground truth\")\nscatter!(p.range, -p.depth; markersize=2, label=\"Estimated\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe have a pretty good match!",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Tracking a drifting transmitter"
    ]
  },
  {
    "objectID": "tut3.html",
    "href": "tut3.html",
    "title": "Channel geometry from impulse response",
    "section": "",
    "text": "Reference\n\n\n\nThis tutorial is adapted from Example C presented in:\n\nMandar Chitre, “Differentiable Ocean Acoustic Propagation Modeling,” in OCEANS 2023 IEEE/MTS – Limerick, 5-8 June 2023.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Channel geometry from impulse response"
    ]
  },
  {
    "objectID": "tut3.html#problem-statement",
    "href": "tut3.html#problem-statement",
    "title": "Channel geometry from impulse response",
    "section": "Problem statement",
    "text": "Problem statement\nConsider a scenario where a bottom-mounted sensor is deployed on a sub-surface mooring at an unknown altitude over the seabed. The exact location of the sensor is unknown, but we know the general area where it is deployed. The sensor is equipped with an acoustic transponder that we can query from a surface unit when we are within a 250 m range of it. We deploy the transducer of the surface unit from the boat on a 7 m rope with a weight attached. Due to currents, the transducer is not hanging perfectly vertically, and so it’s exact depth d1 is not known. The depth sounder of our boat tells us that the water depth h is 20 m, and the Captain of the boat assures us that the bathymetry is quite flat. We query the transponder and get a response. The broadband acoustic response from the transponder allows us to estimate the delays of 4 multipath arrivals. We wish to estimate the depth d2 of the sensor and the range r between the boat and the sensor using the multipath arrival delays.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Channel geometry from impulse response"
    ]
  },
  {
    "objectID": "tut3.html#dataset",
    "href": "tut3.html#dataset",
    "title": "Channel geometry from impulse response",
    "section": "Dataset",
    "text": "Dataset\nTo illustrate this idea, let us generate a synthetic dataset with d1 = 7.2 m, d2 = 12.7 m, h = 20 m, and r = 97.3 m. Since we have an range-independent iso-velocity environment, we can use the PekerisRayTracer (otherwise we could use the RaySolver):\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nusing UnderwaterAcoustics\n\nfunction model(h, r, d1, d2)\n  env = UnderwaterEnvironment(bathymetry=h)\n  pm = PekerisRayTracer(env)\n  tx = AcousticSource(r, -d2, 1000.0)\n  rx = AcousticReceiver(0.0, -d1)\n  arr = arrivals(pm, tx, rx)\n  t = getfield.(arr, :t)        # get a.t for each arrival a in arr\n  (t[2:end] .- t[1]) .* 1000    # relative time in milliseconds\nend\n\ndata = model(20, 97.3, 7.2, 12.7)\n\n6-element Vector{Float64}:\n  1.2078734494638532\n  1.2340398375722539\n  6.4705086705396235\n  3.755897382140966\n 10.919625105605624\n 10.987838758289167",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Channel geometry from impulse response"
    ]
  },
  {
    "objectID": "tut3.html#probabilistic-model",
    "href": "tut3.html#probabilistic-model",
    "title": "Channel geometry from impulse response",
    "section": "Probabilistic model",
    "text": "Probabilistic model\nWe can model this as a Bayesian inference problem using Turing.jl and some reasonable priors:\n\nusing Turing\n\n@model function pmodel(data)\n  h  ~ Normal(20.0, 0.1)\n  r  ~ Uniform(0.0, 250.0)\n  d1 ~ Normal(7.0, 1.0)\n  d2 ~ Uniform(0.0, 20.0)\n  μ = model(h, r, d1, d2)\n  data ~ MvNormal(μ, 0.1)\nend\n\nq = vi(pmodel(data), ADVI(10, 10000))\n\n# extract mean values of parameters h, r, d1 and d2\nμ = mean(rand(q, 10000); dims=2)\n\n\n\n4×1 Matrix{Float64}:\n 20.00639587343052\n 97.26448173277478\n  7.180755801751641\n 12.640652188716981\n\n\nWe see that the estimated values of h, r, d1 and d2 are fairly close to the ground truth values. We can also plot the uncertainty in the estimates:\n\nusing StatsPlots\n\nplot(h -&gt; pdf(q, [h, μ[2], μ[3], μ[4]]), 18, 22; xlabel=\"h\", legend=false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot(r -&gt; pdf(q, [μ[1], r, μ[3], μ[4]]), 50, 150; xlabel=\"r\", legend=false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot(d1 -&gt; pdf(q, [μ[1], μ[2], d1, μ[4]]), 5, 9; xlabel=\"d1\", legend=false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot(d2 -&gt; pdf(q, [μ[1], μ[2], μ[3], d2]), 0, 20; xlabel=\"d2\", legend=false)",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Channel geometry from impulse response"
    ]
  },
  {
    "objectID": "tut4.html",
    "href": "tut4.html",
    "title": "Sound speed profile from impulse response",
    "section": "",
    "text": "Reference\n\n\n\nThis tutorial is adapted from Example D presented in:\n\nMandar Chitre, “Differentiable Ocean Acoustic Propagation Modeling,” in OCEANS 2023 IEEE/MTS – Limerick, 5-8 June 2023.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Sound speed profile from impulse response"
    ]
  },
  {
    "objectID": "tut4.html#problem-statement",
    "href": "tut4.html#problem-statement",
    "title": "Sound speed profile from impulse response",
    "section": "Problem statement",
    "text": "Problem statement\nConsider a setup with a 1 kHz acoustic source at 1 km depth that sends a broadband pulse once every week. A receiver 10 km away at a depth of 800 m measures the impulse response from the received broadband pulse. We assume that we have an initial sound speed profile measurement with a CTD at the start of the experiment. The sound speed profile changes over the weeks of the experiment, and we wish to track the changes using the measured impulse response every week.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Sound speed profile from impulse response"
    ]
  },
  {
    "objectID": "tut4.html#key-idea",
    "href": "tut4.html#key-idea",
    "title": "Sound speed profile from impulse response",
    "section": "Key idea",
    "text": "Key idea\nSince the sound speed profile is an unknown function of depth, we model it using a small 3-layer neural network. We initialize the parameters by training the neural network on the known/estimated sound speed profile from the previous week. We use the neural network to provide sound speed estimates to RaySolver, thus effectively creating a model that combines a numerical physics-based differential equation solver with a data-driven neural network. The hybrid model returns a vector of predicted delays of the first few multipath arrivals in the impulse response. We minimize a loss function that measures the difference between the predictions and measurements using gradient descent and automatic differentiation. This essentially trains the neural network to approximate the sound speed profile via a loss function that utilizes the propagation model. At the end of each week’s training, we get a revised estimate of the sound speed profile.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Sound speed profile from impulse response"
    ]
  },
  {
    "objectID": "tut4.html#dataset",
    "href": "tut4.html#dataset",
    "title": "Sound speed profile from impulse response",
    "section": "Dataset",
    "text": "Dataset\nTo illustrate this idea, let us generate a synthetic dataset:\n\nusing UnderwaterAcoustics\nusing AcousticRayTracers\n\n# define Munk sound speed profile\nstruct MunkSSP &lt;: UnderwaterAcoustics.DepthDependent end\n\nfunction (ssp::MunkSSP)(pos)\n  ϵ = 0.00737\n  z̃ = 2.0 * (-pos.z - 1300.0) / 1300.0\n  1500.0 * (1.0 + ϵ * (z̃ - 1 + exp(-z̃)))\nend\n\n# simulate acoustic propagation using RaySolver to generate impulse response\nfunction model(h, r, d1, d2, c, n)\n  env = UnderwaterEnvironment(bathymetry=h, seabed=Rock, soundspeed=c)\n  pm = RaySolver(env)\n  tx = AcousticSource(0.0, -d1, 1000.0)\n  rx = AcousticReceiver(r, -d2)\n  arr = arrivals(pm, tx, rx)\n  t = getfield.(arr, :t)        # get a.t for each arrival a in arr\n  (t[2:n] .- t[1]) .* 1000      # relative time in milliseconds\nend\n\n# estimated sound speed profile from previous week\nprev_depths = [0, 500.0, 1000.0, 2000.0, 3000.0, 4000.0, 5000.0]\nprev_soundspeeds = [1518.6, 1494.5, 1490.6, 1505.8, 1530.3, 1556.7, 1583.6]\n\n# generate data with first 6 multipath delays\ndata = model(5000.0, 10000.0, 1000.0, 1800.0, MunkSSP(), 7)\n\n6-element Vector{Float64}:\n  178.42786295390846\n 1406.6963669822208\n 2245.763511823167\n 3008.5299257637885\n 4014.4245725479186\n 6395.490526963947\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe previous week’s sound speed profile is shown in the plot above as solid circles, whereas the true sound speed profile is shown as a blue line.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Sound speed profile from impulse response"
    ]
  },
  {
    "objectID": "tut4.html#neural-network-based-propagation-model",
    "href": "tut4.html#neural-network-based-propagation-model",
    "title": "Sound speed profile from impulse response",
    "section": "Neural network based propagation model",
    "text": "Neural network based propagation model\nWe don’t know the sound speed profile, so we will use a small 3-layer neural network to model it:\n\nusing SimpleChains\nusing StaticArrays\nusing Random: MersenneTwister\n\n# neural network based sound speed profile data type\nstruct NeuralSSP{T1,T2} &lt;: UnderwaterAcoustics.DepthDependent\n  model::T1                 # neural network structure\n  ps::T2                    # neural network parameters\n  max_depth::Float64        # used for scaling the input\n  min_soundspeed::Float64   # used for scaling the output\n  max_soundspeed::Float64   # used for scaling the output\nend\n\n# scale input, pass through the neural network, and scale output\nfunction (ssp::NeuralSSP)(pos)\n  z̄ = -pos.z / ssp.max_depth\n  c̄ = only(ssp.model(SA[z̄], ssp.ps))\n  (c̄ + 1) / 2 * (ssp.max_soundspeed - ssp.min_soundspeed) + ssp.min_soundspeed\nend\n\n# define the neural network\nssp = let mlp = SimpleChain(\n    static(1),\n    TurboDense(tanh, 3),\n    TurboDense(tanh, 3),\n    TurboDense(tanh, 1)\n  )\n  ps = SimpleChains.init_params(mlp; rng=MersenneTwister(0))\n  NeuralSSP(mlp, ps, 5000.0, 1450.0, 1600.0)\nend\n\nWe initialize the neural network parameters by training the neural network on the known/estimated sound speed profile from the previous week:\n\nc̄ = @. (prev_soundspeeds - ssp.min_soundspeed) / (ssp.max_soundspeed - ssp.min_soundspeed) * 2 - 1\nz̄ = @. prev_depths / ssp.max_depth\nG = SimpleChains.alloc_threaded_grad(ssp.model)\nL = SimpleChains.add_loss(ssp.model, SquaredLoss(transpose(c̄)))\nSimpleChains.train!(G, ssp.ps, L, transpose(collect(z̄)), SimpleChains.ADAM(0.1), 10000)\n\nWe plot the model output against the training data to check that it fits well:\n\nplot(ssp, -5000, 0; xlabel=\"Sound speed (m/s)\", size=(350, 400))\nscatter!(prev_soundspeeds, -prev_depths)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow we define a loss function that computes the difference between the predictions of RaySolver using the sound speed given by the NeuralSSP, and the measured impulse response:\n\n# compute loss using predictions of RaySolver using the NeuralSSP\nfunction loss(ps)\n  ssp1 = NeuralSSP(ssp.model, ps, 5000.0, 1450.0, 1600.0)\n  pred = model(5000.0, 10000.0, 1000.0, 1800.0, ssp1, length(data)+1)\n  sum(abs2, pred - data)\nend\n\nand perform gradient descent to minimize the loss function:\n\nimport ForwardDiff\n\nη = 1e-6            # learning rate\nps = copy(ssp.ps)   # start with the previous week’s parameters\n\n# this will take a few minutes to run...\nfor i ∈ 1:20\n  g = ForwardDiff.gradient(loss, ps)\n  ps .-= η .* g     # gradient descent\nend\n\nWe plot the trained neural sound speed profile against the ground truth:\n\nlet ssp = NeuralSSP(ssp.model, ps, 5000.0, 1450.0, 1600.0)\n  plot(MunkSSP(), -5000, 0; xlabel=\"Sound speed (m/s)\", size=(350, 400))\n  scatter!(prev_soundspeeds, -prev_depths)\n  plot!(ssp, -5000, 0)\nend\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nand see that it indeed fits quite well!",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Sound speed profile from impulse response"
    ]
  },
  {
    "objectID": "replay.html",
    "href": "replay.html",
    "title": "Channel replay",
    "section": "",
    "text": "Quickstart guide\nThe idea of channel replay was popularized in the underwater domain by the Watermark benchmark. The essential idea is to extract estimates of time-varying impulse response (TVIR) from measurements at sea, and to convolve it with a new signals to estimate what would have been received had that signal been transmitted during the measurement.\n\nLoading a replay channel\nTo do channel replay using UnderwaterAcoustics.jl, we build a AbstractAcousticChannel from the measured TVIR using the BasebandReplayChannel() constructor. It can either take in a TVIR as a matrix or load a TVIR from file (e.g. red.mat):\n\nusing UnderwaterAcoustics\nusing Plots\n\nch = BasebandReplayChannel(\"red.mat\")\n\nBasebandReplayChannel(4 × 48.6 s, 25000.0 Hz, 19200.0 Sa/s)\n\n\nThis channel has 4 receiving hydrophones and can replay up to 48.6 seconds of signal through the measured TVIR. The signal must fit within the frequency band that was used to probe the channel (for the red channel it is 25 ± 4.8 kHz).\nWe can visualize the TVIR for the first hydrophone by plotting it:\n\nplot(ch)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIf we were interested in the second hydrophone, we could specify the hydrophone number to plot:\n\nplot(ch, 2)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSimulating a transmission\nTo pass a signal through the channel, we generate a signal and transmit() it just like through any other AbstractAcousticChannel:\n\nusing SignalAnalysis\n\nx = cw(25000, 0.001, 192000; window=(tukey, 0.5)) |&gt; real\ny = transmit(ch, x; start=1)\n\nSampledSignal @ 192000.0 Hz, 2390×4 Matrix{Float64}:\n -2.30613e-7  -1.68895e-6   -1.1229e-6    -2.03047e-7\n -4.25422e-6  -8.90027e-6    7.01078e-6    4.48666e-6\n -1.3377e-5    3.60596e-6    4.19679e-5    1.89721e-5\n -1.33863e-5   4.80151e-5    7.71856e-5    3.04576e-5\n  5.81851e-6   9.91395e-5    5.37547e-5    7.95031e-6\n  3.28637e-5   9.13493e-5   -7.00844e-5   -6.70238e-5\n  1.7783e-5   -1.71968e-6   -0.00025141   -0.000218488\n -1.15864e-5  -0.000246922  -0.00037416   -0.00021522\n -5.00586e-5  -0.000406431  -0.000210164  -9.42333e-6\n -5.92106e-5  -0.000274687   0.000252787   0.000308203\n  ⋮                                       \n -1.35041e-6   2.11438e-6   -7.64514e-7    1.84144e-6\n -6.89779e-6   9.27182e-6    4.12781e-6   -5.57121e-6\n  5.73854e-6   1.94118e-5   -1.08619e-5   -3.94149e-6\n  1.91871e-5   1.50366e-5   -2.28804e-5    3.53182e-6\n  1.85164e-5  -1.02922e-6   -1.77299e-5    8.50609e-6\n -8.58834e-6  -7.36296e-6    2.74406e-6    3.37492e-6\n -1.52027e-5  -1.24997e-5    1.74962e-5   -8.65891e-6\n -9.08902e-6  -7.5428e-6     1.41824e-5   -9.43826e-6\n -1.10549e-6  -1.07817e-6    3.7533e-6    -3.39312e-6\n\n\nWe have 4 channels of received data since we have 4 hydrophones in the replay TVIR. We plot the transmitted signal and the first 5 ms of the replayed received signal (hydrophone 2):\n\nplot(\n  plot(x; xlims=(0,5)),\n  plot(y[:,2]; xlims=(0,5));\n  layout=(2,1)\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdding noise\nWe can also simulate channels with noise. For example, if we wanted white Gaussian noise with standard deviation σ = 0.1, we can specify that when loading the channel:\n\nch = BasebandReplayChannel(\"red.mat\"; noise=WhiteGaussianNoise(0.1))\ny = transmit(ch, x; start=1)\n\nplot(\n  plot(x; xlims=(0,5)),\n  plot(y[:,2]; xlims=(0,5));\n  layout=(2,1)\n)",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Channel replay"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Julia toolbox for underwater acoustic modeling",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Introduction",
    "section": "Overview",
    "text": "Overview\nThe UnderwaterAcoustics.jl ecosystem provides a set of tools for modeling and simulating underwater acoustic propagation. The main package, UnderwaterAcoustics.jl, defines the core application programming interface (API), and provides a set of core differentiable propagation models and utilities. It also provides support for replay channels, where measurements from the ocean are used to empirically construct channel models. The package is designed to be extensible, allowing other packages to add models to the ecosystem.\nThe AcousticsToolbox.jl package adds support for popular benchmark Fortran models from the Ocean Acoustic Library (OALIB) such as the Bellhop ray tracer and Kraken normal mode models. The AcousticRayTracers.jl package provides a fully differentiable ray tracer RaySolver written in Julia.\n\nThe VirtualAcousticOcean.jl package enables real-time acoustic simulation of underwater communication networks and sonar systems.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#highlights",
    "href": "index.html#highlights",
    "title": "Introduction",
    "section": "Highlights",
    "text": "Highlights\n\nUnderwater acoustic propagation modeling API with pluggable models\nDifferentiable and probabilistic underwater acoustic models\n2D/3D underwater acoustic simulation tools\nReplay channel and noise models\nUnderwater acoustics utility functions\n\n\n\n\n\n\n\nBreaking changes\n\n\n\nThe API has changed significantly in UnderwaterAcoustics.jl v0.4. If you have code that depends on the old API, you may wish to refer to the porting guide before you upgrade.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Introduction",
    "section": "Installation",
    "text": "Installation\nusing Pkg\nPkg.add(\"UnderwaterAcoustics\")",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Introduction",
    "section": "Getting started",
    "text": "Getting started\n\nPropagation & channel modeling\nChannel replay",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#tutorials",
    "href": "index.html#tutorials",
    "title": "Introduction",
    "section": "Tutorials",
    "text": "Tutorials\n\nTracking a drifting transmitter – differentiable propagation modeling and gradient descent\nGeoacoustic inversion with an acoustic profiler – probabilistic modeling and Bayesian inference\nEstimating channel geometry from impulse response – probabilistic modeling and Bayesian inference",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "Introduction",
    "section": "Contributing",
    "text": "Contributing\nContributions in the form of bug reports, feature requests, ideas/suggestions, bug fixes, code enhancements, and documentation updates are most welcome. Please read contribution guidelines if you wish to start contributing.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#talks-publications",
    "href": "index.html#talks-publications",
    "title": "Introduction",
    "section": "Talks & publications",
    "text": "Talks & publications\n\nMandar Chitre, “Differentiable Ocean Acoustic Propagation Modeling,” in OCEANS 2023 IEEE/MTS – Limerick, 5-8 June 2023. [doi]\nMandar Chitre, “Underwater Acoustics in the age of differentiable and probabilistic programming”, UComms 2020 webinar, 3 December 2020.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#citing",
    "href": "index.html#citing",
    "title": "Introduction",
    "section": "Citing",
    "text": "Citing\nIf you use UnderwaterAcoustics.jl in your work or are influenced by its ideas, please cite:\n@inproceedings{chitre2023ua,\n  author={Chitre, Mandar},\n  booktitle={OCEANS 2023 - Limerick},\n  title={Differentiable Ocean Acoustic Propagation Modeling},\n  year={2023},\n  pages={1-8},\n  doi={10.1109/OCEANSLimerick52467.2023.10244307}\n}",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "raysolver.html",
    "href": "raysolver.html",
    "title": "RaySolver",
    "section": "",
    "text": "Model\nAcousticRayTracers.RaySolver\n\n\nDescription\n2½D acoustic Gaussian beam tracer\n\n\nLanguage\nJulia\n\n\nAdvantages\nDifferentiable (forward mode)\n\n\nLimitations\nTell us and we will fix them!\n\n\nDifferentiability\nForwardDiff\nRaySolver is a differentiable 2½D Gaussian beam tracer similar to Bellhop, but fully written in Julia to be compatible with automatic differentiation (AD) tools such as ForwardDiff. Its implementation is largely based on the description in:",
    "crumbs": [
      "<b>Propagation models</b>",
      "RaySolver"
    ]
  },
  {
    "objectID": "raysolver.html#example",
    "href": "raysolver.html#example",
    "title": "RaySolver",
    "section": "Example",
    "text": "Example\n\nusing UnderwaterAcoustics\nusing AcousticRayTracers\nusing Plots\n\nenv = UnderwaterEnvironment(\n  bathymetry = SampledField([200, 150]; x=[0, 1000], interp=:linear),\n  soundspeed = SampledField([1500, 1480, 1495, 1510, 1520]; z=0:-50:-200, interp=:cubic),\n  seabed = SandyClay\n)\npm = RaySolver(env)\n\ntx = AcousticSource(0, -50, 300)\nrx = AcousticReceiver(1000, -100)\nrays = arrivals(pm, tx, rx)\n\nplot(env; xlims=(-10, 1010))\nplot!(tx)\nplot!(rx)\nplot!(rays)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrxs = AcousticReceiverGrid2D(1:1000, -200:0)\nx = transmission_loss(pm, tx, rxs; mode=:coherent)\n\nplot(rxs, x; crange=70)\nplot!(env; xlims=(0,1000), linewidth=3)",
    "crumbs": [
      "<b>Propagation models</b>",
      "RaySolver"
    ]
  },
  {
    "objectID": "raysolver.html#notes",
    "href": "raysolver.html#notes",
    "title": "RaySolver",
    "section": "Notes",
    "text": "Notes\nThe RaySolver propagation model requires that the transmitter is located at \\((x=0, y=0)\\) and all receivers are located in the right half-plane (i.e., \\(x&gt;0\\) and \\(y=0\\)). While this limitation can be worked around in the wrapper by a coordinate transformation, automatic transformation is not yet implemented.",
    "crumbs": [
      "<b>Propagation models</b>",
      "RaySolver"
    ]
  },
  {
    "objectID": "bellhop.html",
    "href": "bellhop.html",
    "title": "Bellhop",
    "section": "",
    "text": "Model\nAcousticsToolbox.Bellhop\n\n\nDescription\nBellhop ray/beam tracer (wrapper)\n\n\nLanguage\nFortran\n\n\nAdvantages\nWell-established benchmark model\n\n\nLimitations\nNot differentiable, 2½D or 3D modeling not supported\nA good overview of the Bellhop model can be found at:",
    "crumbs": [
      "<b>Propagation models</b>",
      "Bellhop"
    ]
  },
  {
    "objectID": "bellhop.html#example",
    "href": "bellhop.html#example",
    "title": "Bellhop",
    "section": "Example",
    "text": "Example\n\nusing UnderwaterAcoustics\nusing AcousticsToolbox\nusing Plots\n\nenv = UnderwaterEnvironment(\n  bathymetry = SampledField([200, 150]; x=[0, 1000], interp=:linear),\n  soundspeed = SampledField([1500, 1480, 1495, 1510, 1520]; z=0:-50:-200, interp=:cubic),\n  seabed = SandyClay\n)\npm = Bellhop(env)\n\ntx = AcousticSource(0, -50, 300)\nrx = AcousticReceiver(1000, -100)\nrays = arrivals(pm, tx, rx)\n\nplot(env; xlims=(-10, 1010))\nplot!(tx)\nplot!(rx)\nplot!(rays)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrxs = AcousticReceiverGrid2D(1:1000, -200:0)\nx = transmission_loss(pm, tx, rxs; mode=:semicoherent)\n\nplot(rxs, x; crange=70)\nplot!(env; xlims=(0,1000), linewidth=3)",
    "crumbs": [
      "<b>Propagation models</b>",
      "Bellhop"
    ]
  },
  {
    "objectID": "bellhop.html#notes",
    "href": "bellhop.html#notes",
    "title": "Bellhop",
    "section": "Notes",
    "text": "Notes\nThe Fortran Bellhop propagation model requires that the transmitter is located at \\((x=0, y=0)\\) and all receivers are located in the right half-plane (i.e., \\(x&gt;0\\) and \\(y=0\\)). While this limitation can be worked around in the wrapper by a coordinate transformation, automatic transformation is not yet implemented.\nAdditionally, this wrapper does not yet support all the features of the original Fortran model. In particular, it does NOT support:\n\n3D environments (i.e., Bellhop 3D)\nRange-dependent sound speed\nN2-linear, analytic or quadratic interpolation for sound speed\nArbitrary reflection coefficients\nDirectional or line sources\nCartesian or ray-centered beams\n\nReceivers on an irregular grid are supported, but not currently optimized for speed (by using the irregular grid option in the Fortran model).",
    "crumbs": [
      "<b>Propagation models</b>",
      "Bellhop"
    ]
  },
  {
    "objectID": "porting.html",
    "href": "porting.html",
    "title": "Porting from v0.3",
    "section": "",
    "text": "The UnderwaterAcoustics.jl API was changed in v0.4 to make it more flexible to accommodate more types of acoustic propagation models, and for improved readability. The changes are summarized below to aid in porting old code to the new version.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Porting from v0.3"
    ]
  },
  {
    "objectID": "porting.html#underwater-acoustics",
    "href": "porting.html#underwater-acoustics",
    "title": "Porting from v0.3",
    "section": "Underwater acoustics",
    "text": "Underwater acoustics\nThe following functions have been renamed:\n\n\n\nOld function name\nNew function name\n\n\n\n\nbubbleresonance\nbubble_resonance\n\n\nindBperλ\nin_dBperλ\n\n\nreflectioncoef\nreflection_coef\n\n\nsurfaceloss\nsurface_reflection_coef\n\n\nwaterdensity\nwater_density",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Porting from v0.3"
    ]
  },
  {
    "objectID": "porting.html#environment-description",
    "href": "porting.html#environment-description",
    "title": "Porting from v0.3",
    "section": "Environment description",
    "text": "Environment description\nVarious attributes of the environment description are now directly accessed as fields, rather than through accessor methods:\n\n\n\nOld accessor\nNew field access\n\n\n\n\naltimetry(env)\nenv.altimetry\n\n\nbathymetry(env)\nenv.bathymetry\n\n\nssp(env)\nenv.soundspeed\n\n\nsalinity(env)\nenv.salinity\n\n\nwaterdensity(env)\nenv.density\n\n\nseasurface(env)\nenv.surface\n\n\nseabed(env)\nenv.seabed\n\n\n\nThe environment description supports fields that can vary with spatial coordinates. This removes the need wrapping of constants with ConstantDepth(), IsoSSP(), etc. Instead, constant fields are just represented by the real numbers directly. Quantities varying with spatial coordinates are represented generically using a SampledField rather than specific types such as SampledSSP.\nThe defaults for an UnderwaterEnvironment have also changed to become more generic. For example, the default seabed is now a RigidBoundary and the default sea surface is a PressureReleaseBoundary. Contrast this against the arbitrary default in v0.3 of the default seabed being a SandySilt.\nNoise is no longer defined as part of the environmental description, and is defined as part of the new channel modeling API.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Porting from v0.3"
    ]
  },
  {
    "objectID": "porting.html#propagation-modeling",
    "href": "porting.html#propagation-modeling",
    "title": "Porting from v0.3",
    "section": "Propagation modeling",
    "text": "Propagation modeling\nThe PekerisRayModel is now renamed to PekerisRayTracer, and takes in maximum number of bounces as an optional argument, instead of number of rays. The eigenrays function is no longer supported, but its functionality is provided by arrivals. While eigenrays was specific to ray models, arrivals is more generic and may return modes, etc, depending on the propagation model. A few other functions have been renamed:\n\n\n\nOld function\nNew function\n\n\n\n\nPekerisRayModel(env, nrays)\nPekerisRayTracer(env, maxbounces)\n\n\neigenrays\narrivals\n\n\ntransmissionloss\ntransmission_loss\n\n\ntransfercoef\nacoustic_field\n\n\nimpulseresponse\nimpulse_response\n\n\n\nThe plotting API no longer takes special keyword arguments such as sources and receivers. Instead, plot recipes are provided for each of the data types directly. So we can plot sources, receivers, arrivals, etc directly:\nenv = UnderwaterEnvironment(bathymetry=20, seabed=SandyClay)\npm = PekerisRayTracer(env)\ntx = AcousticSource(0.0, -5.0, 1000.0)\nrx = AcousticReceiver(100.0, -10.0)\nrays = arrivals(pm, tx, rx)\n\nplot(env)\nplot!(tx)\nplot!(rx)\nplot!(rays)",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Porting from v0.3"
    ]
  },
  {
    "objectID": "porting.html#acoustic-simulations",
    "href": "porting.html#acoustic-simulations",
    "title": "Porting from v0.3",
    "section": "Acoustic simulations",
    "text": "Acoustic simulations\nThe record and recorder functions used for acoustic simulations have been removed. Instead, a new channel modeling API with a transmit function provides similar functionality, but is a lot more flexible.\nExample:\nch = channel(pm, tx, rx, 192000)\ny = transmit(ch, x)                 # for some signal x\n The channel API also supports channel replay and data-driven acoustic channels that are not derived from propagation models.\nSpecific sources such as Pinger and NarrowbandAcousticSource have been removed. Other packages such as SignalAnalysis may be used to create a diverse set of sampled signals that can be transmitted through the acoustic channel using the transmit function.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Porting from v0.3"
    ]
  },
  {
    "objectID": "ext.html",
    "href": "ext.html",
    "title": "Adding new models",
    "section": "",
    "text": "UnderwaterAcoustics.jl is designed to allow the community to extend it by adding propagation models and channel models.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Adding new models"
    ]
  },
  {
    "objectID": "ext.html#propagation-models",
    "href": "ext.html#propagation-models",
    "title": "Adding new models",
    "section": "Propagation models",
    "text": "Propagation models\nA new propagation model (let’s call it MyPropagationModel for illustration) should define a type that extends one of:\n\n\n\n\n\n\nAbstractPropagationModel\nSuperclass for all propagation models.\n\n\n\n\n\n\n\n\n\nAbstractRayPropagationModel\nSuperclass for all ray propagation models.\n\n\n\n\n\n\n\n\n\nAbstractModePropagationModel\nSuperclass for all mode propagation models.\n\n\n\nThe constructor for MyPropagationModel usually will take in an environmental description and optionally, keyword options that control the model:\nMyPropagationModel(env::UnderwaterEnvironment; kwargs...)\nHowever, for data-driven models, the constructor might take in data or partial environmental information and data:\nMyPropagationModel(data; kwargs...)\nMyPropagationModel(env, data; kwargs...)\nThe following methods should be defined for MyPropagationModel:\nacoustic_field\nThe acoustic field is represented by complex numbers with amplitude that is related to the source level (spl) and transmission loss, and angle that is related to the acoustic phase at the source frequency.\n\n\n\n\n\n\nAdditional options\n\n\n\nThe acoustic_field(), transmission_loss(), arrivals() and impulse_response() methods may support propagation model specific keyword arguments (options) to control finer details of the propagation model.\n\n\nA transmission_loss() method may be optionally defined for MyPropagationModel:\n\n\n\n\n\n\ntransmission_loss(pm, tx, rxs)\nCompute the transmission loss from the source tx to the receivers rxs using propagation model pm. If rxs denotes a single receiver, the result is a scalar. If rxs is an AbstractArray, the result is an array of transmission losses (in dB) with the same shape as rxs.\n\n\n\nIf it is not defined, the transmission loss is automatically computed as 20 * log10(acoustic_field(...)).\nA propagation model should also typically define:\n\n\n\n\n\n\narrivals(pm, tx, rx; paths=true)\nCompute the arrivals at the receiver rx due to the source tx using propagation model pm. Returns an array of arrivals.\nThe eigenray paths are typically included in the arrivals. However, if they are not needed, one may set paths=false to allow the propagation model to avoid computing them.\n\n\n\nThe returned arrivals should be an array of arrivals that extend:\n\n\n\n\n\n\nAbstractAcousticArrival\nSuperclass for all acoustic arrivals.\n\n\n\nThe information held in an arrival is propagation model dependent. For example, ray models may return arrivals that contain ray information such as time of arrival, angle of arrival, amplitude and phase of arrival, eigenpath, etc. On the other hand, models based on normal modes may return arrivals containing mode information such as mode number, horizontal and vertical wavenumber, etc. For ray and mode arrivals, the following concrete subtypes should be used when possible:\n\n\n\n\n\n\nRayArrival\nType representing a single acoustic ray arrival.\nProperties:\n\nt / time: arrival time (s)\nϕ / phasor: complex amplitude\nns / surface_bounces: number of surface bounces\nnb / bottom_bounces: number of bottom bounces\nθₛ / launch_angle: launch angle at source (rad)\nθᵣ / arrival_angle: arrival angle at receiver (rad)\npath: ray path (optional, vector of 3-tuples or missing)\n\nThe properties are accessible with the short names for brevity, and longer more descriptive names where readability is desired or unicode symbols are undesired.\n\n\n\n\n\n\n\n\n\nModeArrival\nType representing a single acoustic mode arrival.\nProperties:\n\nm / mode: mode number\nkᵣ / hwavenumber: horizontal wavenumber (rad/m)\nψ(z) / mode_function: mode function\nv / group_velocity: group velocity (m/s)\n\nThe properties are accessible with the short names for brevity, and longer more descriptive names where readability is desired or unicode symbols are undesired.\n\n\n\nSome propagation models may be able to generate an impulse response. If so, they should define:\n\n\n\n\n\n\nimpulse_response(pm, tx, rx, fs; abstime=false, ntaps=nothing)\nCompute the impulse response at the receiver rx due to the source tx using propagation model pm at the given sampling frequency fs. If abstime is true, the result is in absolute time from the start of transmission. Otherwise, the result is relative to the earliest arrival time of the signal at the receiver (possibly with some guard period to accommodate acausal response). ntaps specifies the number of taps in the impulse response. If not specified, the number of taps is chosen automatically based on the arrival times.\n\n\n\nIf defined, the impulse response may be used to generate a channel model automatically (by calling channel()).",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Adding new models"
    ]
  },
  {
    "objectID": "ext.html#channel-model",
    "href": "ext.html#channel-model",
    "title": "Adding new models",
    "section": "Channel model",
    "text": "Channel model\nIf a propagation model can estimate a received signal from a transmit signal without having to compute an impulse response and convolve it, it may wish to implement the channel modeling API directly:\n\n\n\n\n\n\nchannel(pm, txs, rxs, fs; noise=nothing)\nCompute a channel model from the sources txs to the receivers rxs using propagation model pm. The result is a channel model with the same number of input channels as the number of sources and output channels as the number of receivers. The channel model accepts signals sampled at rate fs and returns signals sampled at the same rate.\nAn additive noise model may be optionally specified as noise. If specified, it is used to corrupt the received signals.\n\n\n\nThe returned channel model must extend:\n\n\n\n\n\n\nAbstractChannelModel\nSuperclass for all channel models.\n\n\n\nand support:\n\n\n\n\n\n\ntransmit(ch, x; txs=:, rxs=:, abstime=false, noisy=true, fs=nothing)\nSimulate the transmission of passband signal x through the channel model ch. If txs is specified, it specifies the indices of the sources active in the simulation. The number of sources must match the number of channels in the input signal. If rxs is specified, it specifies the indices of the receivers active in the simulation. Returns the received signal at the specified (or all) receivers.\nfs specifies the sampling rate of the input signal. The output signal is sampled at the same rate. If fs is not specified but x is a SampledSignal, the sampling rate of x is used. Otherwise, the signal is assumed to be sampled at the channel’s sampling rate.\nIf abstime is true, the returned signals begin at the start of transmission. Otherwise, the result is relative to the earliest arrival time of the signal at any receiver. If noisy is true and the channel has a noise model associated with it, the received signal is corrupted by additive noise.\n\n\n\nIn some cases (e.g. channel replay techniques), a channel model may be defined without the need to derive it from a propagation model. In such a case, one may extend UnderwaterAcoustics.jl by directly defining the channel model.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Adding new models"
    ]
  }
]