[
  {
    "objectID": "pos.html",
    "href": "pos.html",
    "title": "Positions and units",
    "section": "",
    "text": "We often need 1D, 2D or 3D positions to describe the location of a source, receiver, or other object in the underwater environment. The canonical representation for positions is a named 3-tuple of coordinates of the form (x=0.0, y=0.0, z=0.0). We define the generic data type XYZ to represent such a named tuple:\nconst XYZ = NamedTuple{(:x,:y,:z)}\n\nIt is sometimes more convenient to represent positions in simpler forms, with just a single or two-coordinates. In most places where positions are expected, we automatically convert various input representations to a XYZ. This allows the user to specify scalars, tuples, or named tuples as input. For example, the AcousticReceiver(‚ãØ) accepts receiver position as input:\n\nusing UnderwaterAcoustics\n\n# The following are all equivalent:\n@info AcousticReceiver((x=0, y=0, z=-10)).pos\n@info AcousticReceiver((x=0, z=-10)).pos\n@info AcousticReceiver((z=-10,)).pos\n@info AcousticReceiver((0, 0, -10)).pos\n@info AcousticReceiver((0, -10)).pos\n@info AcousticReceiver(-10).pos\n@info AcousticReceiver(0, 0, -10).pos\n@info AcousticReceiver(0, -10).pos\n\n\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n\n\n\n\nThe last two forms are only available in functions that accept no other positional arguments (other than position), and therefore do not cause any confusion as to the meaning of positional arguments.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Positions and units"
    ]
  },
  {
    "objectID": "pos.html#positions",
    "href": "pos.html#positions",
    "title": "Positions and units",
    "section": "",
    "text": "We often need 1D, 2D or 3D positions to describe the location of a source, receiver, or other object in the underwater environment. The canonical representation for positions is a named 3-tuple of coordinates of the form (x=0.0, y=0.0, z=0.0). We define the generic data type XYZ to represent such a named tuple:\nconst XYZ = NamedTuple{(:x,:y,:z)}\n\nIt is sometimes more convenient to represent positions in simpler forms, with just a single or two-coordinates. In most places where positions are expected, we automatically convert various input representations to a XYZ. This allows the user to specify scalars, tuples, or named tuples as input. For example, the AcousticReceiver(‚ãØ) accepts receiver position as input:\n\nusing UnderwaterAcoustics\n\n# The following are all equivalent:\n@info AcousticReceiver((x=0, y=0, z=-10)).pos\n@info AcousticReceiver((x=0, z=-10)).pos\n@info AcousticReceiver((z=-10,)).pos\n@info AcousticReceiver((0, 0, -10)).pos\n@info AcousticReceiver((0, -10)).pos\n@info AcousticReceiver(-10).pos\n@info AcousticReceiver(0, 0, -10).pos\n@info AcousticReceiver(0, -10).pos\n\n\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n[ Info: (x = 0.0, y = 0.0, z = -10.0)\n\n\n\n\nThe last two forms are only available in functions that accept no other positional arguments (other than position), and therefore do not cause any confusion as to the meaning of positional arguments.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Positions and units"
    ]
  },
  {
    "objectID": "pos.html#units",
    "href": "pos.html#units",
    "title": "Positions and units",
    "section": "Units",
    "text": "Units\nWe also support units though Unitful.jl. Internally, all quantities are represented as floating point numbers without explicit units, with standard units (mostly SI units) assumed implicitly. Input quantities are automatically converted to the implicit units as necessary. For example, positions can be specified with units:\n\n# The following are all equivalent:\n@info AcousticReceiver(1000, -10).pos\n@info AcousticReceiver(1000u\"m\", -10u\"m\").pos\n@info AcousticReceiver(1u\"km\", -10u\"m\").pos\n@info AcousticReceiver((1u\"km\", -10u\"m\")).pos\n@info AcousticReceiver((x=1u\"km\", z=-1000u\"cm\")).pos\n\n\n[ Info: (x = 1000.0, y = 0.0, z = -10.0)\n[ Info: (x = 1000.0, y = 0.0, z = -10.0)\n[ Info: (x = 1000.0, y = 0.0, z = -10.0)\n[ Info: (x = 1000.0, y = 0.0, z = -10.0)\n[ Info: (x = 1000.0, y = 0.0, z = -10.0)\n\n\n\n\nWe may also use units in other places:\n\n@show soundspeed(0u\"¬∞C\");\n@show soundspeed(32u\"¬∞F\");\n@show reflection_coef(10¬∞, 1.2, 1.5);   # const ¬∞ is defined as u\"¬∞\"\n@show absorption(10u\"kHz\");\n\nsoundspeed(0 * u\"¬∞C\") = 1448.96\nsoundspeed(32 * u\"¬∞F\") = 1448.96\nreflection_coef(10¬∞, 1.2, 1.5) = 0.294789169055958 + 0.0im\nabsorption(10 * u\"kHz\") = 0.9253039111184715\n\n\nincluding environment descriptions:\n\nenv = UnderwaterEnvironment(\n  soundspeed = 1.5u\"km/s\",\n  temperature = 60u\"¬∞F\",\n  salinity = 35u\"ppt\",\n  density = 1.025u\"g/cm^3\",\n  bathymetry = 100u\"m\"\n)\n\nUnderwaterEnvironment(\n  bathymetry = 100, \n  altimetry = 0.0, \n  temperature = 140//9, \n  salinity = 35, \n  pH = 8.1, \n  soundspeed = 1500.0, \n  density = 1025.0, \n  seabed = RigidBoundary, \n  surface = PressureReleaseBoundary, \n)",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Positions and units"
    ]
  },
  {
    "objectID": "pos.html#extending",
    "href": "pos.html#extending",
    "title": "Positions and units",
    "section": "Extending",
    "text": "Extending\nWhile standard UnderwaterAcoustics.jl API functions automatically convert input values to the appropriate XYZ and units, you may wish to support these features in your own code when extending UnderwaterAcoustics.jl. To do so, you may use the unexported function xyz(‚ãØ) to create a position from various different forms. You may also use the unexported in_units(‚ãØ) function to convert input values to the appropriate units:\nusing UnderwaterAcoustics: XYZ, in_units\n\nfunction myfunction(pos, temperature)\n  pos = xyz(pos)\n  temperature = in_units(u\"¬∞C\", temperature)\n  # ‚ãØ\nend\n\nAPI reference\n\n\n\n\n\n\nxyz(pos)\nxyz(x, y, z)\nxyz(x, z)\nxyz(z)\nConvert a position to a named tuple with fields x, y, and z. If any of the coordinates is not provided, they are assumed to be zero. If the coordinates have units, they are converted to meters.\n\n\n\n\n\n\n\n\n\nin_units(u, x)\nGet the numerical value of x in units of u. If x is a Unitful.Quantity, it is converted to u. If x is a number, it is assumed to be in u and is returned as is.\nIf u is u\"dB\", the x may be specified as a number of a u\"dB\" quantity. In both cases, the numerical value of x in dB is returned.\n\nExamples\njulia&gt; in_units(u\"Hz\", 10u\"kHz\")\n10000\n\njulia&gt; in_units(u\"m\", 10)\n10\n\njulia&gt; in_units(u\"m\", 1u\"cm\")\n1//100\n\njulia&gt; in_units(u\"dB\", 3)\n3\n\njulia&gt; in_units(u\"dB\", 3u\"dB\")\n3\n\n\n\n\n\n\n\n\n\n\ndistance(p1, p2)\nCompute distance between two positions.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Positions and units"
    ]
  },
  {
    "objectID": "ext.html",
    "href": "ext.html",
    "title": "Adding new models",
    "section": "",
    "text": "UnderwaterAcoustics.jl is designed to allow the community to extend it by adding propagation models and channel models.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Adding new models"
    ]
  },
  {
    "objectID": "ext.html#propagation-models",
    "href": "ext.html#propagation-models",
    "title": "Adding new models",
    "section": "Propagation models",
    "text": "Propagation models\nA new propagation model (let‚Äôs call it MyPropagationModel for illustration) should define a type that extends one of:\n\n\n\n\n\n\nAbstractPropagationModel\nSuperclass for all propagation models.\n\n\n\n\n\n\n\n\n\nAbstractRayPropagationModel\nSuperclass for all ray propagation models.\n\n\n\n\n\n\n\n\n\nAbstractModePropagationModel\nSuperclass for all mode propagation models.\n\n\n\nThe constructor for MyPropagationModel usually will take in an environmental description and optionally, keyword options that control the model:\nMyPropagationModel(env::UnderwaterEnvironment; kwargs...)\nHowever, for data-driven models, the constructor might take in data or partial environmental information and data:\nMyPropagationModel(data; kwargs...)\nMyPropagationModel(env, data; kwargs...)\nThe following methods should be defined for MyPropagationModel:\nacoustic_field\nThe acoustic field is represented by complex numbers with amplitude that is related to the source level (spl) and transmission loss, and angle that is related to the acoustic phase at the source frequency.\n\n\n\n\n\n\nAdditional options\n\n\n\nThe acoustic_field(), transmission_loss(), arrivals() and impulse_response() methods may support propagation model specific keyword arguments (options) to control finer details of the propagation model.\n\n\nA transmission_loss() method may be optionally defined for MyPropagationModel:\n\n\n\n\n\n\ntransmission_loss(pm, tx, rxs)\nCompute the transmission loss from the source tx to the receivers rxs using propagation model pm. If rxs denotes a single receiver, the result is a scalar. If rxs is an AbstractArray, the result is an array of transmission losses (in dB) with the same shape as rxs.\n\n\n\nIf it is not defined, the transmission loss is automatically computed as 20 * log10(acoustic_field(...)).\nA propagation model should also typically define:\n\n\n\n\n\n\narrivals(pm, tx, rx; paths=true)\nCompute the arrivals at the receiver rx due to the source tx using propagation model pm. Returns an array of arrivals.\nFor ray models, eigenray paths are typically included in the arrivals. However, if they are not needed, one may set paths=false to allow the propagation model to avoid computing them.\n\n\n\nThe returned arrivals should be an array of arrivals that extend:\n\n\n\n\n\n\nAbstractAcousticArrival\nSuperclass for all acoustic arrivals.\n\n\n\nThe information held in an arrival is propagation model dependent. For example, ray models may return arrivals that contain ray information such as time of arrival, angle of arrival, amplitude and phase of arrival, eigenpath, etc. On the other hand, models based on normal modes may return arrivals containing mode information such as mode number, horizontal and vertical wavenumber, etc. For ray and mode arrivals, the following concrete subtypes should be used when possible:\n\n\n\n\n\n\nRayArrival\nType representing a single acoustic ray arrival.\nProperties:\n\nt / time: arrival time (s)\nœï / phasor: complex amplitude\nns / surface_bounces: number of surface bounces\nnb / bottom_bounces: number of bottom bounces\nŒ∏‚Çõ / launch_angle: launch angle at source (rad)\nŒ∏·µ£ / arrival_angle: arrival angle at receiver (rad)\npath: ray path (optional, vector of 3-tuples or missing)\n\nThe properties are accessible with the short names for brevity, and longer more descriptive names where readability is desired or unicode symbols are undesired.\n\n\n\n\n\n\n\n\n\nModeArrival\nType representing a single acoustic mode arrival.\nProperties:\n\nm / mode: mode number\nk·µ£ / hwavenumber: horizontal wavenumber (rad/m)\nœà(z) / mode_function: mode function\nv / group_velocity: group velocity (m/s)\nv‚Çö / phase_velocity: phase velocity (m/s)\n\nThe properties are accessible with the short names for brevity, and longer more descriptive names where readability is desired or unicode symbols are undesired.\n\n\n\nSome propagation models may be able to generate an impulse response. If so, they should define:\n\n\n\n\n\n\nimpulse_response(pm, tx, rx, fs; abstime=false, ntaps=nothing)\nCompute the impulse response at the receiver rx due to the source tx using propagation model pm at the given sampling frequency fs. If abstime is true, the result is in absolute time from the start of transmission. Otherwise, the result is relative to the earliest arrival time of the signal at the receiver (possibly with some guard period to accommodate acausal response). ntaps specifies the number of taps in the impulse response. If not specified, the number of taps is chosen automatically based on the arrival times.\nimpulse_response(pm, tx, rx, fs; abstime, ntaps, fmin, fmax)\nCompute the impulse response at the receiver rx due to the source tx using propagation model pm at the given sampling frequency fs.\nIf abstime is true (default is false), the result is in absolute time from the start of transmission. Otherwise, the result is relative to the earliest arrival time of the signal at the receiver (with some guard period to accommodate acausal response).\nntaps specifies the number of taps in the impulse response. If not specified, the number of taps is chosen automatically based on the arrival times.\nfmin and fmax specifies the bandwidth of interest. If unspecified, a 50% bandwidth is assumed, i.e., if the transmitter frequency is 300 Hz the bandwidth of interest is assumed to be 150 Hz (fmin = 225, fmax = 375). Larger bandwidths require more modal computations, and hence increase computational load.\nThe impulse response is computed only for positive frequencies. Such an impulse response is suitable for convolution with passband complex analytic signals. If convolved with real signals, the resulting signal is approximately equivalent to converting the real signal to a complex analytic form and then convolving it with the impulse response.\n\n\n\nIf defined, the impulse response may be used to generate a channel model automatically (by calling channel()).",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Adding new models"
    ]
  },
  {
    "objectID": "ext.html#channel-model",
    "href": "ext.html#channel-model",
    "title": "Adding new models",
    "section": "Channel model",
    "text": "Channel model\nIf a propagation model can estimate a received signal from a transmit signal without having to compute an impulse response and convolve it, it may wish to implement the channel modeling API directly:\n\n\n\n\n\n\nchannel(pm, txs, rxs, fs; noise=nothing)\nCompute a channel model from the sources txs to the receivers rxs using propagation model pm. The result is a channel model with the same number of input channels as the number of sources and output channels as the number of receivers. The channel model accepts signals sampled at rate fs and returns signals sampled at the same rate.\nAn additive noise model may be optionally specified as noise. If specified, it is used to corrupt the received signals.\n\n\n\nThe returned channel model must extend:\n\n\n\n\n\n\nAbstractChannelModel\nSuperclass for all channel models.\n\n\n\nand support:\n\n\n\n\n\n\ntransmit(ch, x; txs=:, rxs=:, abstime=false, noisy=true, fs=nothing)\nSimulate the transmission of passband signal x through the channel model ch. If txs is specified, it specifies the indices of the sources active in the simulation. The number of sources must match the number of channels in the input signal. If rxs is specified, it specifies the indices of the receivers active in the simulation. Returns the received signal at the specified (or all) receivers.\nfs specifies the sampling rate of the input signal. The output signal is sampled at the same rate. If fs is not specified but x is a SampledSignal, the sampling rate of x is used. Otherwise, the signal is assumed to be sampled at the channel‚Äôs sampling rate.\nIf abstime is true, the returned signals begin at the start of transmission. Otherwise, the result is relative to the earliest arrival time of the signal at any receiver. If noisy is true and the channel has a noise model associated with it, the received signal is corrupted by additive noise.\n\n\n\nIn some cases (e.g.¬†channel replay techniques), a channel model may be defined without the need to derive it from a propagation model. In such a case, one may extend UnderwaterAcoustics.jl by directly defining the channel model.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Adding new models"
    ]
  },
  {
    "objectID": "porting.html",
    "href": "porting.html",
    "title": "Porting from v0.3",
    "section": "",
    "text": "The UnderwaterAcoustics.jl API was changed in v0.4 to make it more flexible to accommodate more types of acoustic propagation models, and for improved readability. The changes are summarized below to aid in porting old code to the new version.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Porting from v0.3"
    ]
  },
  {
    "objectID": "porting.html#underwater-acoustics",
    "href": "porting.html#underwater-acoustics",
    "title": "Porting from v0.3",
    "section": "Underwater acoustics",
    "text": "Underwater acoustics\nThe following functions have been renamed:\n\n\n\nOld function name\nNew function name\n\n\n\n\nbubbleresonance\nbubble_resonance\n\n\nindBperŒª\nin_dBperŒª\n\n\nreflectioncoef\nreflection_coef\n\n\nsurfaceloss\nsurface_reflection_coef\n\n\nwaterdensity\nwater_density",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Porting from v0.3"
    ]
  },
  {
    "objectID": "porting.html#environment-description",
    "href": "porting.html#environment-description",
    "title": "Porting from v0.3",
    "section": "Environment description",
    "text": "Environment description\nVarious attributes of the environment description are now directly accessed as fields, rather than through accessor methods:\n\n\n\nOld accessor\nNew field access\n\n\n\n\naltimetry(env)\nenv.altimetry\n\n\nbathymetry(env)\nenv.bathymetry\n\n\nssp(env)\nenv.soundspeed\n\n\nsalinity(env)\nenv.salinity\n\n\nwaterdensity(env)\nenv.density\n\n\nseasurface(env)\nenv.surface\n\n\nseabed(env)\nenv.seabed\n\n\n\nThe environment description supports fields that can vary with spatial coordinates. This removes the need wrapping of constants with ConstantDepth(), IsoSSP(), etc. Instead, constant fields are just represented by the real numbers directly. Quantities varying with spatial coordinates are represented generically using a SampledField rather than specific types such as SampledSSP.\nThe defaults for an UnderwaterEnvironment have also changed to become more generic. For example, the default seabed is now a RigidBoundary and the default sea surface is a PressureReleaseBoundary. Contrast this against the arbitrary default in v0.3 of the default seabed being a SandySilt.\nNoise is no longer defined as part of the environmental description, and is defined as part of the new channel modeling API.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Porting from v0.3"
    ]
  },
  {
    "objectID": "porting.html#propagation-modeling",
    "href": "porting.html#propagation-modeling",
    "title": "Porting from v0.3",
    "section": "Propagation modeling",
    "text": "Propagation modeling\nThe PekerisRayModel is now renamed to PekerisRayTracer, and takes in maximum number of bounces as an optional argument, instead of number of rays. The eigenrays function is no longer supported, but its functionality is provided by arrivals. While eigenrays was specific to ray models, arrivals is more generic and may return modes, etc, depending on the propagation model. A few other functions have been renamed:\n\n\n\nOld function\nNew function\n\n\n\n\nPekerisRayModel(env, nrays)\nPekerisRayTracer(env, maxbounces)\n\n\neigenrays\narrivals\n\n\ntransmissionloss\ntransmission_loss\n\n\ntransfercoef\nacoustic_field\n\n\nimpulseresponse\nimpulse_response\n\n\n\nThe plotting API no longer takes special keyword arguments such as sources and receivers. Instead, plot recipes are provided for each of the data types directly. So we can plot sources, receivers, arrivals, etc directly:\nenv = UnderwaterEnvironment(bathymetry=20, seabed=SandyClay)\npm = PekerisRayTracer(env)\ntx = AcousticSource(0.0, -5.0, 1000.0)\nrx = AcousticReceiver(100.0, -10.0)\nrays = arrivals(pm, tx, rx)\n\nplot(env)\nplot!(tx)\nplot!(rx)\nplot!(rays)",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Porting from v0.3"
    ]
  },
  {
    "objectID": "porting.html#acoustic-simulations",
    "href": "porting.html#acoustic-simulations",
    "title": "Porting from v0.3",
    "section": "Acoustic simulations",
    "text": "Acoustic simulations\nThe record and recorder functions used for acoustic simulations have been removed. Instead, a new channel modeling API with a transmit function provides similar functionality, but is a lot more flexible.\nExample:\nch = channel(pm, tx, rx, 192000)\ny = transmit(ch, x)                 # for some signal x\n The channel API also supports channel replay and data-driven acoustic channels that are not derived from propagation models.\nSpecific sources such as Pinger and NarrowbandAcousticSource have been removed. Other packages such as SignalAnalysis may be used to create a diverse set of sampled signals that can be transmitted through the acoustic channel using the transmit function.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Porting from v0.3"
    ]
  },
  {
    "objectID": "bellhop.html",
    "href": "bellhop.html",
    "title": "Bellhop",
    "section": "",
    "text": "Model\nAcousticsToolbox.Bellhop\n\n\nDescription\nBellhop ray/beam tracer (wrapper)\n\n\nLanguage\nFortran\n\n\nAdvantages\nWell-established benchmark model\n\n\nLimitations\nNot differentiable, 2¬ΩD or 3D modeling not supported\nA good overview of the Bellhop model can be found at:",
    "crumbs": [
      "<b>Propagation models</b>",
      "Bellhop"
    ]
  },
  {
    "objectID": "bellhop.html#example",
    "href": "bellhop.html#example",
    "title": "Bellhop",
    "section": "Example",
    "text": "Example\n\nusing UnderwaterAcoustics\nusing AcousticsToolbox\nusing Plots\n\nenv = UnderwaterEnvironment(\n  bathymetry = SampledField([200, 150]; x=[0, 1000], interp=:linear),\n  soundspeed = SampledField([1500, 1480, 1495, 1510, 1520]; z=0:-50:-200, interp=:cubic),\n  seabed = SandyClay\n)\npm = Bellhop(env)\n\ntx = AcousticSource(0, -50, 300)\nrx = AcousticReceiver(1000, -100)\nrays = arrivals(pm, tx, rx)\n\nplot(env; xlims=(-10, 1010))\nplot!(tx)\nplot!(rx)\nplot!(rays)\n\n\n\n\n\nrxs = AcousticReceiverGrid2D(1:1000, -200:0)\nx = transmission_loss(pm, tx, rxs; mode=:semicoherent)\n\nplot(rxs, x; crange=70)\nplot!(env; xlims=(0,1000), linewidth=3)",
    "crumbs": [
      "<b>Propagation models</b>",
      "Bellhop"
    ]
  },
  {
    "objectID": "bellhop.html#notes",
    "href": "bellhop.html#notes",
    "title": "Bellhop",
    "section": "Notes",
    "text": "Notes\nThe Fortran Bellhop propagation model requires that the transmitter is located at \\((x=0, y=0)\\) and all receivers are located in the right half-plane (i.e., \\(x&gt;0\\) and \\(y=0\\)). While this limitation can be worked around in the wrapper by a coordinate transformation, automatic transformation is not yet implemented.\nAdditionally, this wrapper does not yet support all the features of the original Fortran model. In particular, it does NOT support:\n\n3D environments (i.e., Bellhop 3D)\nRange-dependent sound speed\nN2-linear, analytic or quadratic interpolation for sound speed\nArbitrary reflection coefficients\nDirectional or line sources\nCartesian or ray-centered beams\n\nReceivers on an irregular grid are supported, but not currently optimized for speed (by using the irregular grid option in the Fortran model).",
    "crumbs": [
      "<b>Propagation models</b>",
      "Bellhop"
    ]
  },
  {
    "objectID": "raysolver.html",
    "href": "raysolver.html",
    "title": "RaySolver",
    "section": "",
    "text": "Model\nAcousticRayTracers.RaySolver\n\n\nDescription\n2¬ΩD acoustic Gaussian beam tracer\n\n\nLanguage\nJulia\n\n\nAdvantages\nDifferentiable (forward mode)\n\n\nLimitations\nTell us and we will fix them!\n\n\nDifferentiability\nForwardDiff\nRaySolver is a differentiable 2¬ΩD Gaussian beam tracer similar to Bellhop, but fully written in Julia to be compatible with automatic differentiation (AD) tools such as ForwardDiff. Its implementation is largely based on the description in:",
    "crumbs": [
      "<b>Propagation models</b>",
      "RaySolver"
    ]
  },
  {
    "objectID": "raysolver.html#example",
    "href": "raysolver.html#example",
    "title": "RaySolver",
    "section": "Example",
    "text": "Example\n\nusing UnderwaterAcoustics\nusing AcousticRayTracers\nusing Plots\n\nenv = UnderwaterEnvironment(\n  bathymetry = SampledField([200, 150]; x=[0, 1000], interp=:linear),\n  soundspeed = SampledField([1500, 1480, 1495, 1510, 1520]; z=0:-50:-200, interp=:cubic),\n  seabed = SandyClay\n)\npm = RaySolver(env)\n\ntx = AcousticSource(0, -50, 300)\nrx = AcousticReceiver(1000, -100)\nrays = arrivals(pm, tx, rx)\n\nplot(env; xlims=(-10, 1010))\nplot!(tx)\nplot!(rx)\nplot!(rays)\n\n\n\n\n\nrxs = AcousticReceiverGrid2D(1:1000, -200:0)\nx = transmission_loss(pm, tx, rxs; mode=:coherent)\n\nplot(rxs, x; crange=70)\nplot!(env; xlims=(0,1000), linewidth=3)",
    "crumbs": [
      "<b>Propagation models</b>",
      "RaySolver"
    ]
  },
  {
    "objectID": "raysolver.html#notes",
    "href": "raysolver.html#notes",
    "title": "RaySolver",
    "section": "Notes",
    "text": "Notes\nThe RaySolver propagation model requires that the transmitter is located at \\((x=0, y=0)\\) and all receivers are located in the right half-plane (i.e., \\(x&gt;0\\) and \\(y=0\\)). While this limitation can be worked around in the wrapper by a coordinate transformation, automatic transformation is not yet implemented.",
    "crumbs": [
      "<b>Propagation models</b>",
      "RaySolver"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Julia toolbox for underwater acoustic modeling",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Introduction",
    "section": "Overview",
    "text": "Overview\nThe UnderwaterAcoustics.jl ecosystem provides a set of tools for modeling and simulating underwater acoustic propagation. The main package, UnderwaterAcoustics.jl, defines the core application programming interface (API), and provides a set of core differentiable propagation models and utilities. It also provides support for replay channels, where measurements from the ocean are used to empirically construct channel models. The package is designed to be extensible, allowing other packages to add models to the ecosystem.\nThe AcousticsToolbox.jl package adds support for popular benchmark Fortran models from the Ocean Acoustic Library (OALIB) such as the Bellhop ray tracer and Kraken normal mode models. The AcousticRayTracers.jl package provides a fully differentiable ray tracer RaySolver written in Julia.\n\nThe VirtualAcousticOcean.jl package enables real-time acoustic simulation of underwater communication networks and sonar systems.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#highlights",
    "href": "index.html#highlights",
    "title": "Introduction",
    "section": "Highlights",
    "text": "Highlights\n\nUnderwater acoustic propagation modeling API with pluggable models\nDifferentiable and probabilistic underwater acoustic models\n2D/3D underwater acoustic simulation tools\nReplay channel and noise models\nUnderwater acoustics utility functions\n\n\n\n\n\n\n\nBreaking changes\n\n\n\nThe API has changed significantly in UnderwaterAcoustics.jl v0.4. If you have code that depends on the old API, you may wish to refer to the porting guide before you upgrade.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Introduction",
    "section": "Installation",
    "text": "Installation\nusing Pkg\nPkg.add(\"UnderwaterAcoustics\")",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Introduction",
    "section": "Getting started",
    "text": "Getting started\n\nPropagation & channel modeling\nChannel replay",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#tutorials",
    "href": "index.html#tutorials",
    "title": "Introduction",
    "section": "Tutorials",
    "text": "Tutorials\n\nTracking a drifting transmitter ‚Äì differentiable propagation modeling and gradient descent\nGeoacoustic inversion with an acoustic profiler ‚Äì probabilistic modeling and Bayesian inference\nChannel geometry from impulse response ‚Äì probabilistic modeling and Bayesian inference\nSound speed profile from impulse response ‚Äì combining neural networks with physics-based models",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "Introduction",
    "section": "Contributing",
    "text": "Contributing\nContributions in the form of bug reports, feature requests, ideas/suggestions, bug fixes, code enhancements, and documentation updates are most welcome. Please read contribution guidelines if you wish to start contributing.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#talks-publications",
    "href": "index.html#talks-publications",
    "title": "Introduction",
    "section": "Talks & publications",
    "text": "Talks & publications\n\nMandar Chitre, ‚ÄúDifferentiable Ocean Acoustic Propagation Modeling,‚Äù in OCEANS 2023 IEEE/MTS ‚Äì Limerick, 5-8 June 2023. [doi]\nMandar Chitre, ‚ÄúUnderwater Acoustics in the age of differentiable and probabilistic programming‚Äù, UComms 2020 webinar, 3 December 2020.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#citing",
    "href": "index.html#citing",
    "title": "Introduction",
    "section": "Citing",
    "text": "Citing\nIf you use UnderwaterAcoustics.jl in your work or are influenced by its ideas, please cite:\n@inproceedings{chitre2023ua,\n  author={Chitre, Mandar},\n  booktitle={OCEANS 2023 - Limerick},\n  title={Differentiable Ocean Acoustic Propagation Modeling},\n  year={2023},\n  pages={1-8},\n  doi={10.1109/OCEANSLimerick52467.2023.10244307}\n}",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Introduction"
    ]
  },
  {
    "objectID": "replay.html",
    "href": "replay.html",
    "title": "Channel replay",
    "section": "",
    "text": "Quickstart guide\nThe idea of channel replay was popularized in the underwater domain by the Watermark benchmark. The essential idea is to extract estimates of time-varying impulse response (TVIR) from measurements at sea, and to convolve it with a new signals to estimate what would have been received had that signal been transmitted during the measurement.\n\nLoading a replay channel\nTo do channel replay using UnderwaterAcoustics.jl, we build a AbstractAcousticChannel from the measured TVIR using the BasebandReplayChannel() constructor. It can either take in a TVIR as a matrix or load a TVIR from file (e.g.¬†red.mat):\n\nusing UnderwaterAcoustics\nusing Plots\n\nch = BasebandReplayChannel(\"red.mat\")\n\nBasebandReplayChannel(4 √ó 48.6 s, 25000.0 Hz, 19200.0 Sa/s)\n\n\nThis channel has 4 receiving hydrophones and can replay up to 48.6 seconds of signal through the measured TVIR. The signal must fit within the frequency band that was used to probe the channel (for the red channel it is 25 ¬± 4.8 kHz).\nWe can visualize the TVIR for the first hydrophone by plotting it:\n\nplot(ch)\n\n\n\n\nIf we were interested in the second hydrophone, we could specify the hydrophone number to plot:\n\nplot(ch, 2)\n\n\n\n\n\n\nSimulating a transmission\nTo pass a signal through the channel, we generate a signal and transmit() it just like through any other AbstractAcousticChannel:\n\nusing SignalAnalysis\n\nx = cw(25000, 0.001, 192000; window=(tukey, 0.5)) |&gt; real\ny = transmit(ch, x; start=1)\n\nSampledSignal @ 192000.0 Hz, 2390√ó4 Matrix{Float64}:\n -2.36394e-7  -1.69694e-6   -1.12269e-6   -2.06586e-7\n -4.29307e-6  -8.93096e-6    6.95876e-6    4.47084e-6\n -1.33684e-5   3.69249e-6    4.18005e-5    1.90144e-5\n -1.32064e-5   4.8353e-5     7.69898e-5    3.06228e-5\n  6.18467e-6   9.96305e-5    5.37913e-5    8.18552e-6\n  3.31883e-5   9.15604e-5   -6.95737e-5   -6.69293e-5\n  1.76456e-5  -2.32089e-6   -0.000250489  -0.000218782\n -1.24373e-5  -0.000248442  -0.000373429  -0.000215902\n -5.13562e-5  -0.000408098  -0.000210405  -1.01444e-5\n -6.00964e-5  -0.000275095   0.000251239   0.000308053\n  ‚ãÆ                                       \n -1.35583e-6   2.11055e-6   -7.73661e-7    1.83786e-6\n -6.88518e-6   9.24505e-6    4.15114e-6   -5.58047e-6\n  5.75698e-6   1.93389e-5   -1.08536e-5   -3.94562e-6\n  1.91887e-5   1.49698e-5   -2.29123e-5    3.54112e-6\n  1.84976e-5  -1.03803e-6   -1.77804e-5    8.52323e-6\n -8.61728e-6  -7.32348e-6    2.71239e-6    3.37459e-6\n -1.52188e-5  -1.2458e-5     1.74921e-5   -8.65725e-6\n -9.08914e-6  -7.52549e-6    1.41939e-5   -9.43631e-6\n -1.10073e-6  -1.07966e-6    3.76185e-6   -3.39226e-6\n\n\nWe have 4 channels of received data since we have 4 hydrophones in the replay TVIR. We plot the transmitted signal and the first 5 ms of the replayed received signal (hydrophone 2):\n\nplot(\n  plot(x; xlims=(0,5)),\n  plot(y[:,2]; xlims=(0,5));\n  layout=(2,1)\n)\n\n\n\n\n\n\nAdding noise\nWe can also simulate channels with noise. For example, if we wanted white Gaussian noise with standard deviation œÉ = 0.1, we can specify that when loading the channel:\n\nch = BasebandReplayChannel(\"red.mat\"; noise=WhiteGaussianNoise(0.1))\ny = transmit(ch, x; start=1)\n\nplot(\n  plot(x; xlims=(0,5)),\n  plot(y[:,2]; xlims=(0,5));\n  layout=(2,1)\n)",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Channel replay"
    ]
  },
  {
    "objectID": "tut4.html",
    "href": "tut4.html",
    "title": "Sound speed profile from impulse response",
    "section": "",
    "text": "Reference\n\n\n\nThis tutorial is adapted from Example D presented in:\n\nMandar Chitre, ‚ÄúDifferentiable Ocean Acoustic Propagation Modeling,‚Äù in OCEANS 2023 IEEE/MTS ‚Äì Limerick, 5-8 June 2023.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Sound speed profile from impulse response"
    ]
  },
  {
    "objectID": "tut4.html#problem-statement",
    "href": "tut4.html#problem-statement",
    "title": "Sound speed profile from impulse response",
    "section": "Problem statement",
    "text": "Problem statement\nConsider a setup with a 1 kHz acoustic source at 1 km depth that sends a broadband pulse once every week. A receiver 10 km away at a depth of 800 m measures the impulse response from the received broadband pulse. We assume that we have an initial sound speed profile measurement with a CTD at the start of the experiment. The sound speed profile changes over the weeks of the experiment, and we wish to track the changes using the measured impulse response every week.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Sound speed profile from impulse response"
    ]
  },
  {
    "objectID": "tut4.html#key-idea",
    "href": "tut4.html#key-idea",
    "title": "Sound speed profile from impulse response",
    "section": "Key idea",
    "text": "Key idea\nSince the sound speed profile is an unknown function of depth, we model it using a small 3-layer neural network. We initialize the parameters by training the neural network on the known/estimated sound speed profile from the previous week. We use the neural network to provide sound speed estimates to RaySolver, thus effectively creating a model that combines a numerical physics-based differential equation solver with a data-driven neural network. The hybrid model returns a vector of predicted delays of the first few multipath arrivals in the impulse response. We minimize a loss function that measures the difference between the predictions and measurements using gradient descent and automatic differentiation. This essentially trains the neural network to approximate the sound speed profile via a loss function that utilizes the propagation model. At the end of each week‚Äôs training, we get a revised estimate of the sound speed profile.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Sound speed profile from impulse response"
    ]
  },
  {
    "objectID": "tut4.html#dataset",
    "href": "tut4.html#dataset",
    "title": "Sound speed profile from impulse response",
    "section": "Dataset",
    "text": "Dataset\nTo illustrate this idea, let us generate a synthetic dataset:\n\nusing UnderwaterAcoustics\nusing AcousticRayTracers\n\n# define Munk sound speed profile\nstruct MunkSSP &lt;: UnderwaterAcoustics.DepthDependent end\n\nfunction (ssp::MunkSSP)(pos)\n  œµ = 0.00737\n  zÃÉ = 2.0 * (-pos.z - 1300.0) / 1300.0\n  1500.0 * (1.0 + œµ * (zÃÉ - 1 + exp(-zÃÉ)))\nend\n\n# simulate acoustic propagation using RaySolver to generate impulse response\nfunction model(h, r, d1, d2, c, n)\n  env = UnderwaterEnvironment(bathymetry=h, seabed=Rock, soundspeed=c)\n  pm = RaySolver(env)\n  tx = AcousticSource(0.0, -d1, 1000.0)\n  rx = AcousticReceiver(r, -d2)\n  arr = arrivals(pm, tx, rx)\n  t = getfield.(arr, :t)        # get a.t for each arrival a in arr\n  (t[2:n] .- t[1]) .* 1000      # relative time in milliseconds\nend\n\n# estimated sound speed profile from previous week\nprev_depths = [0, 500.0, 1000.0, 2000.0, 3000.0, 4000.0, 5000.0]\nprev_soundspeeds = [1518.6, 1494.5, 1490.6, 1505.8, 1530.3, 1556.7, 1583.6]\n\n# generate data with first 6 multipath delays\ndata = model(5000.0, 10000.0, 1000.0, 1800.0, MunkSSP(), 7)\n\n6-element Vector{Float64}:\n  178.42786295390846\n 1406.6963669822208\n 2245.763511823167\n 3008.5299257637885\n 4014.4245725479186\n 6395.490526963947\n\n\n\n\n\n\n\nThe previous week‚Äôs sound speed profile is shown in the plot above as solid circles, whereas the true sound speed profile is shown as a blue line.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Sound speed profile from impulse response"
    ]
  },
  {
    "objectID": "tut4.html#neural-network-based-propagation-model",
    "href": "tut4.html#neural-network-based-propagation-model",
    "title": "Sound speed profile from impulse response",
    "section": "Neural network based propagation model",
    "text": "Neural network based propagation model\nWe don‚Äôt know the sound speed profile, so we will use a small 3-layer neural network to model it:\n\nusing SimpleChains\nusing StaticArrays\nusing Random: MersenneTwister\n\n# neural network based sound speed profile data type\nstruct NeuralSSP{T1,T2} &lt;: UnderwaterAcoustics.DepthDependent\n  model::T1                 # neural network structure\n  ps::T2                    # neural network parameters\n  max_depth::Float64        # used for scaling the input\n  min_soundspeed::Float64   # used for scaling the output\n  max_soundspeed::Float64   # used for scaling the output\nend\n\n# scale input, pass through the neural network, and scale output\nfunction (ssp::NeuralSSP)(pos)\n  zÃÑ = -pos.z / ssp.max_depth\n  cÃÑ = only(ssp.model(SA[zÃÑ], ssp.ps))\n  (cÃÑ + 1) / 2 * (ssp.max_soundspeed - ssp.min_soundspeed) + ssp.min_soundspeed\nend\n\n# define the neural network\nssp = let mlp = SimpleChain(\n    static(1),\n    TurboDense(tanh, 3),\n    TurboDense(tanh, 3),\n    TurboDense(tanh, 1)\n  )\n  ps = SimpleChains.init_params(mlp; rng=MersenneTwister(0))\n  NeuralSSP(mlp, ps, 5000.0, 1450.0, 1600.0)\nend\n\nWe initialize the neural network parameters by training the neural network on the known/estimated sound speed profile from the previous week:\n\ncÃÑ = @. (prev_soundspeeds - ssp.min_soundspeed) / (ssp.max_soundspeed - ssp.min_soundspeed) * 2 - 1\nzÃÑ = @. prev_depths / ssp.max_depth\nG = SimpleChains.alloc_threaded_grad(ssp.model)\nL = SimpleChains.add_loss(ssp.model, SquaredLoss(transpose(cÃÑ)))\nSimpleChains.train!(G, ssp.ps, L, transpose(collect(zÃÑ)), SimpleChains.ADAM(0.1), 10000)\n\nWe plot the model output against the training data to check that it fits well:\n\nplot(ssp, -5000, 0; xlabel=\"Sound speed (m/s)\", size=(350, 400))\nscatter!(prev_soundspeeds, -prev_depths)\n\n\n\n\nNow we define a loss function that computes the difference between the predictions of RaySolver using the sound speed given by the NeuralSSP, and the measured impulse response:\n\n# compute loss using predictions of RaySolver using the NeuralSSP\nfunction loss(ps)\n  ssp1 = NeuralSSP(ssp.model, ps, 5000.0, 1450.0, 1600.0)\n  pred = model(5000.0, 10000.0, 1000.0, 1800.0, ssp1, length(data)+1)\n  sum(abs2, pred - data)\nend\n\nand perform gradient descent to minimize the loss function:\n\nimport ForwardDiff\n\nŒ∑ = 1e-6            # learning rate\nps = copy(ssp.ps)   # start with the previous week‚Äôs parameters\n\n# this will take a few minutes to run...\nfor i ‚àà 1:20\n  g = ForwardDiff.gradient(loss, ps)\n  ps .-= Œ∑ .* g     # gradient descent\nend\n\nWe plot the trained neural sound speed profile against the ground truth:\n\nlet ssp = NeuralSSP(ssp.model, ps, 5000.0, 1450.0, 1600.0)\n  plot(MunkSSP(), -5000, 0; xlabel=\"Sound speed (m/s)\", size=(350, 400))\n  scatter!(prev_soundspeeds, -prev_depths)\n  plot!(ssp, -5000, 0)\nend\n\n\n\n\nand see that it indeed fits quite well!",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Sound speed profile from impulse response"
    ]
  },
  {
    "objectID": "tut3.html",
    "href": "tut3.html",
    "title": "Channel geometry from impulse response",
    "section": "",
    "text": "Reference\n\n\n\nThis tutorial is adapted from Example C presented in:\n\nMandar Chitre, ‚ÄúDifferentiable Ocean Acoustic Propagation Modeling,‚Äù in OCEANS 2023 IEEE/MTS ‚Äì Limerick, 5-8 June 2023.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Channel geometry from impulse response"
    ]
  },
  {
    "objectID": "tut3.html#problem-statement",
    "href": "tut3.html#problem-statement",
    "title": "Channel geometry from impulse response",
    "section": "Problem statement",
    "text": "Problem statement\nConsider a scenario where a bottom-mounted sensor is deployed on a sub-surface mooring at an unknown altitude over the seabed. The exact location of the sensor is unknown, but we know the general area where it is deployed. The sensor is equipped with an acoustic transponder that we can query from a surface unit when we are within a 250 m range of it. We deploy the transducer of the surface unit from the boat on a 7 m rope with a weight attached. Due to currents, the transducer is not hanging perfectly vertically, and so it‚Äôs exact depth d1 is not known. The depth sounder of our boat tells us that the water depth h is 20 m, and the Captain of the boat assures us that the bathymetry is quite flat. We query the transponder and get a response. The broadband acoustic response from the transponder allows us to estimate the delays of 4 multipath arrivals. We wish to estimate the depth d2 of the sensor and the range r between the boat and the sensor using the multipath arrival delays.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Channel geometry from impulse response"
    ]
  },
  {
    "objectID": "tut3.html#dataset",
    "href": "tut3.html#dataset",
    "title": "Channel geometry from impulse response",
    "section": "Dataset",
    "text": "Dataset\nTo illustrate this idea, let us generate a synthetic dataset with d1 = 7.2 m, d2 = 12.7 m, h = 20 m, and r = 97.3 m. Since we have an range-independent iso-velocity environment, we can use the PekerisRayTracer (otherwise we could use the RaySolver):\n\n\n\n\n\n\nusing UnderwaterAcoustics\n\nfunction model(h, r, d1, d2)\n  env = UnderwaterEnvironment(bathymetry=h)\n  pm = PekerisRayTracer(env; max_bounces=4)\n  tx = AcousticSource(r, -d2, 1000.0)\n  rx = AcousticReceiver(0.0, -d1)\n  arr = arrivals(pm, tx, rx)\n  t = getfield.(arr, :t)        # get a.t for each arrival a in arr\n  (t[2:end] .- t[1]) .* 1000    # relative time in milliseconds\nend\n\ndata = model(20, 97.3, 7.2, 12.7)\n\n8-element Vector{Float64}:\n  1.2078734494638532\n  1.2340398375722539\n  6.4705086705396235\n  3.755897382140966\n 10.919625105605624\n 10.987838758289167\n 20.841074171559228\n 16.304090813082887",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Channel geometry from impulse response"
    ]
  },
  {
    "objectID": "tut3.html#probabilistic-model",
    "href": "tut3.html#probabilistic-model",
    "title": "Channel geometry from impulse response",
    "section": "Probabilistic model",
    "text": "Probabilistic model\nWe can model this as a Bayesian inference problem using Turing.jl and some reasonable priors:\n\nusing Turing\nusing Random\n\n@model function pmodel(data)\n  h  ~ Normal(20.0, 0.1)\n  r  ~ Uniform(0.0, 250.0)\n  d1 ~ Normal(7.0, 1.0)\n  d2 ~ Uniform(0.0, 20.0)\n  Œº = model(h, r, d1, d2)\n  data ~ MvNormal(Œº, 0.1)\nend\n\nm = pmodel(data)\nq,_ = vi(MersenneTwister(1), m, q_meanfield_gaussian(m), 10000)\n\n# extract mean values of parameters h, r, d1 and d2\nŒº = mean(rand(q, 10000); dims=2)\n\n\n\n4√ó1 Matrix{Float64}:\n 20.009226482010614\n 97.42325326194218\n  7.200312567411043\n 12.704686858499537\n\n\nWe see that the estimated values of h, r, d1 and d2 are fairly close to the ground truth values. We can also plot the uncertainty in the estimates:\n\nusing StatsPlots\n\nplot(h -&gt; pdf(q, [h, Œº[2], Œº[3], Œº[4]]), 18, 22; xlabel=\"h\", legend=false)\n\n\n\n\n\nplot(r -&gt; pdf(q, [Œº[1], r, Œº[3], Œº[4]]), 50, 150; xlabel=\"r\", legend=false)\n\n\n\n\n\nplot(d1 -&gt; pdf(q, [Œº[1], Œº[2], d1, Œº[4]]), 5, 9; xlabel=\"d1\", legend=false)\n\n\n\n\n\nplot(d2 -&gt; pdf(q, [Œº[1], Œº[2], Œº[3], d2]), 0, 20; xlabel=\"d2\", legend=false)",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Channel geometry from impulse response"
    ]
  },
  {
    "objectID": "tut1.html",
    "href": "tut1.html",
    "title": "Tracking a drifting transmitter",
    "section": "",
    "text": "References\n\n\n\nThis tutorial is adapted from Example A presented in:\n\nMandar Chitre, ‚ÄúDifferentiable Ocean Acoustic Propagation Modeling,‚Äù in OCEANS 2023 IEEE/MTS ‚Äì Limerick, 5-8 June 2023.\n\nA version of this example was also presented in the UComms 2020 webinar:\n\nMandar Chitre, ‚ÄúUnderwater Acoustics in the age of differentiable and probabilistic programming‚Äù, UComms 2020 webinar, 3 December 2020.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Tracking a drifting transmitter"
    ]
  },
  {
    "objectID": "tut1.html#problem-statement",
    "href": "tut1.html#problem-statement",
    "title": "Tracking a drifting transmitter",
    "section": "Problem statement",
    "text": "Problem statement\nLet us consider a scenario where a drifting probe acoustically transmits its sensor data periodically to a static receiver. The initial position of the sensor is perfectly known, and so is the environment. But the path of the sensor as it drifts is not known, but we‚Äôd like to get an estimate of it from the received acoustic signal. Due to the high data rate requirements, the receiver uses an equalization technique that requires an accurate estimate of the channel impulse response. We want to generate that using a propagation model and an accurate estimate of the location of the probe.\nThe environment is an iso-velocity channel with a constant depth of 20 m and known seabed parameters (density œÅ = 1500 kg/m¬≥, sound speed c = 1850 m/s, and attenuation Œ¥ = 0.001). The probe uses a 1-2 kHz band for data transmission, and includes 101 pilots at 10 Hz spacing to aid with channel estimation. The transmission loss can be accurately measured at those pilot frequencies, since the transmit source level is assumed to be known, but phase information is assumed to be unavailable at each pilot.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Tracking a drifting transmitter"
    ]
  },
  {
    "objectID": "tut1.html#dataset",
    "href": "tut1.html#dataset",
    "title": "Tracking a drifting transmitter",
    "section": "Dataset",
    "text": "Dataset\nTo illustrate the idea, we generate a 60-transmission dataset with a linearly drifting path for the transmitter. Since we have an range-independent iso-velocity environment, we can use the PekerisRayTracer (otherwise we could use the RaySolver):\n\nusing UnderwaterAcoustics\nusing DataFrames\n\nfunction ùí¥((r, d, f, œÅ, c, Œ¥))\n  env = UnderwaterEnvironment(\n    bathymetry = 20.0,\n    seabed = FluidBoundary(œÅ, c, Œ¥)\n  )\n  tx = AcousticSource(r, -d, f)\n  rx = AcousticReceiver(0.0, -5.0)\n  pm = PekerisRayTracer(env)\n  transmission_loss(pm, tx, rx)\nend\n\ndata = DataFrame([(\n    range=100.0 + 0.5t,\n    depth=6.0 + 0.01t,\n    pilots=[ùí¥([100.0 + 0.5t, 6.0 + 0.01t, f, 1500.0, 1850.0, 0.001]) for f ‚àà 1000.0:10.0:2000.0]\n  ) for t ‚àà 0.0:1.0:59.0])",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Tracking a drifting transmitter"
    ]
  },
  {
    "objectID": "tut1.html#gradient-descent",
    "href": "tut1.html#gradient-descent",
    "title": "Tracking a drifting transmitter",
    "section": "Gradient descent",
    "text": "Gradient descent\nIn order to recover the drift path of the probe, we build a simple error model for the measured pilots. We initialize the model with the known starting location of the probe, and track the probe by minimizing the error through gradient descent.\nSince our propagation model is differentiable, the gradient of the error can be automatically computed during the optimization using ForwardDiff.jl.\n\nusing ForwardDiff\n\n# channel model for pilots\npilots(r, d) = [ùí¥([r, d, f, 1500.0, 1850.0, 0.001]) for f ‚àà 1000.0:10.0:2000.0]\n\n# gradient descent optimization\nfunction chparams(data)\n  history = []\n  Œ∏ = [100.0, 6.0]    # known initial location\n  Œ∑ = [1e-4, 1e-6]    # learning rate\n  for row ‚àà eachrow(data)\n    err(Œ∏) = sum(abs2, pilots(Œ∏[1], Œ∏[2]) .- row.pilots)  # error model\n    for i ‚àà 1:100      # iterations of simple gradient descent\n      Œ∏ .-=  Œ∑ .* ForwardDiff.gradient(err, Œ∏)\n    end\n    push!(history, (range=Œ∏[1], depth=Œ∏[2]))\n  end\n  DataFrame(history)\nend\n\np = chparams(data)\n\nNow that we have a path estimate, let‚Äôs check it against the ground truth:\n\nusing Plots\n\nplot(data.range, -data.depth; linewidth=2, xlabel=\"Range (m)\", ylabel=\"Depth (m)\", label=\"Ground truth\")\nscatter!(p.range, -p.depth; markersize=2, label=\"Estimated\")\n\n\n\n\nWe have a pretty good match!",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Tracking a drifting transmitter"
    ]
  },
  {
    "objectID": "pekeris-modes.html",
    "href": "pekeris-modes.html",
    "title": "PekerisModeSolver",
    "section": "",
    "text": "Model\nUnderwaterAcoustics.PekerisModeSolver\n\n\nDescription\nNormal mode model for constant depth iso-velocity environments\n\n\nLanguage\nJulia\n\n\nAdvantages\nFast, differentiable (forward mode), multi-threaded\n\n\nLimitations\nIso-velocity, pressure-release surface, fluid half-space seabed, no seabed absorption (no leaky modes)\n\n\nDifferentiability\nForwardDiff\nImplementation largely based on mathematical description in:\nWhile the PekerisModeSolver is range-independent by itself, it can be made range-dependent by using AdiabaticExt as shown in the example below.",
    "crumbs": [
      "<b>Propagation models</b>",
      "PekerisModeSolver"
    ]
  },
  {
    "objectID": "pekeris-modes.html#examples",
    "href": "pekeris-modes.html#examples",
    "title": "PekerisModeSolver",
    "section": "Examples",
    "text": "Examples\n\nRange-independent scenario\n\nusing UnderwaterAcoustics\nusing Plots\n\nenv = UnderwaterEnvironment(\n  bathymetry = 5000,\n  soundspeed = 1500,\n  density = 1000,\n  seabed = FluidBoundary(2000, 2000)\n)\npm = PekerisModeSolver(env)\n\ntx = AcousticSource(0, -500, 10)\nrx = AcousticReceiver(200000, -2500)\nmodes = arrivals(pm, tx, rx)[1:7]      # first 7 modes\n\n7-element Vector{UnderwaterAcoustics.ModeArrival{ComplexF64, UnderwaterAcoustics.Mode{Float64}, Float64, Float64}}:\n   mode 1: k·µ£ = 0.041883 - 0.0im rad/m, v = 1499.84 m/s, v‚Çö = 1500.16 m/s\n   mode 2: k·µ£ = 0.04187 - 0.0im rad/m, v = 1499.36 m/s, v‚Çö = 1500.66 m/s\n   mode 3: k·µ£ = 0.041847 - 0.0im rad/m, v = 1498.56 m/s, v‚Çö = 1501.48 m/s\n   mode 4: k·µ£ = 0.041815 - 0.0im rad/m, v = 1497.45 m/s, v‚Çö = 1502.63 m/s\n   mode 5: k·µ£ = 0.041773 - 0.0im rad/m, v = 1496.01 m/s, v‚Çö = 1504.12 m/s\n   mode 6: k·µ£ = 0.041723 - 0.0im rad/m, v = 1494.24 m/s, v‚Çö = 1505.94 m/s\n   mode 7: k·µ£ = 0.041663 - 0.0im rad/m, v = 1492.15 m/s, v‚Çö = 1508.10 m/s\n\n\n\n# plot the modes\nplot(modes)\n\n\n\n\n\nrxs = AcousticReceiverGrid2D(200000:10:220000, -2500)\nx = transmission_loss(pm, tx, rxs)\n\nplot(200:0.01:220, x; ylims=(70,110), yflip=true, legend=false,\n  xlabel=\"Range (km)\", ylabel=\"Transmission loss (dB)\")\n\n\n\n\n\n\nRange-dependent scenario\n\nusing UnderwaterAcoustics\nusing Plots\n\nenv = UnderwaterEnvironment(\n  bathymetry = SampledField([200, 150, 200]; x=[0, 2000, 5000], interp=:linear),\n  soundspeed = 1500,\n  density = 1000,\n  seabed = FluidBoundary(2000, 2000)\n)\n\n# use an adiabatic extension to the PekerisModeSolver for range-dependence\npm = AdiabaticExt(PekerisModeSolver, env)\n\ntx = AcousticSource(0, -50, 250)\nrx = AcousticReceiver(7000, -25)\nmodes = arrivals(pm, tx, rx)[1:7]      # first 7 modes\n\n7-element Vector{UnderwaterAcoustics.ModeArrival{ComplexF64, UnderwaterAcoustics.Mode{Float64}, Float64, Float64}}:\n   mode 1: k·µ£ = 1.047083 - 0.0im rad/m, v = 1499.80 m/s, v‚Çö = 1500.16 m/s\n   mode 2: k·µ£ = 1.04674 - 0.0im rad/m, v = 1499.22 m/s, v‚Çö = 1500.66 m/s\n   mode 3: k·µ£ = 1.046167 - 0.0im rad/m, v = 1498.24 m/s, v‚Çö = 1501.48 m/s\n   mode 4: k·µ£ = 1.045364 - 0.0im rad/m, v = 1496.86 m/s, v‚Çö = 1502.63 m/s\n   mode 5: k·µ£ = 1.044331 - 0.0im rad/m, v = 1495.09 m/s, v‚Çö = 1504.12 m/s\n   mode 6: k·µ£ = 1.043066 - 0.0im rad/m, v = 1492.91 m/s, v‚Çö = 1505.94 m/s\n   mode 7: k·µ£ = 1.04157 - 0.0im rad/m, v = 1490.34 m/s, v‚Çö = 1508.10 m/s\n\n\n\n# plot the modes\nplot(modes)\n\n\n\n\n\nrxs = AcousticReceiverGrid2D(10:10:7000, -200:1)\nx = transmission_loss(pm, tx, rxs)\n\nplot(rxs, x; crange=50)\nplot!(env)\n\n\n\n\nWe can also estimate a bandlimited impulse response from the propagation model:\n\nplot(impulse_response(pm, tx, rx, 8000; fmin=200, fmax=300))",
    "crumbs": [
      "<b>Propagation models</b>",
      "PekerisModeSolver"
    ]
  },
  {
    "objectID": "pekeris-modes.html#notes",
    "href": "pekeris-modes.html#notes",
    "title": "PekerisModeSolver",
    "section": "Notes",
    "text": "Notes\n\nDifferentiability currently works only with ForwardDiff, and excludes impulse_response().",
    "crumbs": [
      "<b>Propagation models</b>",
      "PekerisModeSolver"
    ]
  },
  {
    "objectID": "tut2.html",
    "href": "tut2.html",
    "title": "Geoacoustic inversion with an acoustic profiler",
    "section": "",
    "text": "References\n\n\n\nThis tutorial is adapted from Example B presented in:\n\nMandar Chitre, ‚ÄúDifferentiable Ocean Acoustic Propagation Modeling,‚Äù in OCEANS 2023 IEEE/MTS ‚Äì Limerick, 5-8 June 2023.\n\nA version of this example was also presented in the UComms 2020 webinar:\n\nMandar Chitre, ‚ÄúUnderwater Acoustics in the age of differentiable and probabilistic programming‚Äù, UComms 2020 webinar, 3 December 2020.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Geoacoustic inversion with an acoustic profiler"
    ]
  },
  {
    "objectID": "tut2.html#problem-statement",
    "href": "tut2.html#problem-statement",
    "title": "Geoacoustic inversion with an acoustic profiler",
    "section": "Problem statement",
    "text": "Problem statement\nWe consider a geoacoustic inversion problem where we have a static omnidirectional broadband acoustic source transmitting in a 5‚Äì7 kHz band, and a single omnidirectional receiver that records the signal at a fixed range. The receiver is able to profile the water column, and therefore makes transmission loss measurements at various depths. We wish to estimate seabed parameters from the transmission loss measurements. Do note that although we have acoustic measurements at various depths, they cannot be used for beamforming to separate out the bottom reflected arrival from other arrivals. We therefore only have transmission loss at each depth for our inversion.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Geoacoustic inversion with an acoustic profiler"
    ]
  },
  {
    "objectID": "tut2.html#dataset",
    "href": "tut2.html#dataset",
    "title": "Geoacoustic inversion with an acoustic profiler",
    "section": "Dataset",
    "text": "Dataset\nTo illustrate this idea, let us generate a synthetic dataset for a known set of seabed parameters (density œÅ = 1500 kg/m¬≥, soundspeed c = 1850 m/s, and attenuation Œ¥ = 0.001). The environment is assumed to be an iso-velocity and with a constant depth of 20 m. The source is at a depth of 5 m. The receiver is at a range of 100 m from the source, and makes measurements at depths from 1 to 19 m in steps of 1 m.\n\n\n\n\n\nSince we have an range-independent iso-velocity environment, we can use the PekerisRayTracer (otherwise we could use the RaySolver):\n\nusing UnderwaterAcoustics\nusing DataFrames\n\nfunction ùí¥(Œ∏)\n  r, d, f, œÅ, c, Œ¥ = Œ∏\n  env = UnderwaterEnvironment(\n    bathymetry = 20.0,\n    seabed = FluidBoundary(œÅ, c, Œ¥)\n  )\n  tx = AcousticSource(0.0, -5.0, f)\n  rx = AcousticReceiver(r, -d)\n  pm = PekerisRayTracer(env)\n  transmission_loss(pm, tx, rx)\nend\n\ndata = DataFrame([\n  (depth=d, frequency=f, xloss=ùí¥([100.0, d, f, 1500.0, 1850.0, 0.001]))\n  for d ‚àà 1.0:1.0:19.0 for f ‚àà 5000.0:100.0:7000.0\n])",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Geoacoustic inversion with an acoustic profiler"
    ]
  },
  {
    "objectID": "tut2.html#probabilistic-model",
    "href": "tut2.html#probabilistic-model",
    "title": "Geoacoustic inversion with an acoustic profiler",
    "section": "Probabilistic model",
    "text": "Probabilistic model\nWe use some very loose uniform priors for œÅ, c and Œ¥, and estimate the transmission loss using the same model ùí¥, as used in the data generation, but without information on the actual seabed parameters. We assume that the measurements of transmission loss are normally distributed around the modeled transmission loss, with a covariance of 0.5 dB.\nWe define the probabilistic model as a Turing.jl model:\n\nusing Turing\nusing Random\n\n# depths d, frequencies f, transmission loss measurements x\n@model function geoacoustic(d, f, x)\n  œÅ ~ Uniform(1300.0, 1700.0)\n  c ~ Uniform(750.0, 2000.0)\n  Œ¥ ~ Uniform(0.0, 0.003)\n  Œº = [ùí¥([100.0, d[i], f[i], œÅ, c, Œ¥]) for i ‚àà 1:length(d)]\n  x ~ MvNormal(Œº, 0.5)\nend",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Geoacoustic inversion with an acoustic profiler"
    ]
  },
  {
    "objectID": "tut2.html#variational-inference",
    "href": "tut2.html#variational-inference",
    "title": "Geoacoustic inversion with an acoustic profiler",
    "section": "Variational inference",
    "text": "Variational inference\nOnce we have the model defined, we can run Bayesian inference on it. We could either use MCMC methods from Turing, or variational inference. Since our model is differentiable, we choose to use the automatic differentiation variational inference (ADVI):\n\n# this may take a minute or two to run...\nm = geoacoustic(data.depth, data.frequency, data.xloss)\nq,_ = vi(MersenneTwister(1), m, q_fullrank_gaussian(m), 1000)\n\nThe returned q is a 3-dimensional posterior probability distribution over the parameters œÅ, c and Œ¥. We can estimate the mean of the distribution by drawing random variates and taking the sample mean:\n\nŒº = mean(rand(q, 10000); dims=2)\n\n3√ó1 Matrix{Float64}:\n 1498.6347981557428\n 1850.456841075752\n    0.0015953014519568332\n\n\nWe see that the estimated parameter means for œÅ, c and Œ¥ are quite close to the actual values used in generating the data.\nWe can also plot the conditional distributions of each parameter:\n\nusing StatsPlots\n\nplot(œÅ -&gt; pdf(q, [œÅ, Œº[2], Œº[3]]), 1300, 1700; xlabel=\"œÅ\", legend=false)\n\n\n\n\n\nplot(c -&gt; pdf(q, [Œº[1], c, Œº[3]]), 1650, 1950; xlabel=\"c\", legend=false)\n\n\n\n\n\nplot(Œ¥ -&gt; pdf(q, [Œº[1], Œº[2], Œ¥]), 0.0, 0.003; xlabel=\"Œ¥\", legend=false)",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Geoacoustic inversion with an acoustic profiler"
    ]
  },
  {
    "objectID": "pekeris-rays.html",
    "href": "pekeris-rays.html",
    "title": "PekerisRayTracer",
    "section": "",
    "text": "Model\nUnderwaterAcoustics.PekerisRayTracer\n\n\nDescription\nRay tracer for constant depth iso-velocity environments\n\n\nLanguage\nJulia\n\n\nAdvantages\nFast, differentiable\n\n\nLimitations\nIso-velocity, range-independent\n\n\nDifferentiability\nForwardDiff, Zygote, Mooncake, Enzyme\nImplementation based on mathematical description in:",
    "crumbs": [
      "<b>Propagation models</b>",
      "PekerisRayTracer"
    ]
  },
  {
    "objectID": "pekeris-rays.html#example",
    "href": "pekeris-rays.html#example",
    "title": "PekerisRayTracer",
    "section": "Example",
    "text": "Example\n\nusing UnderwaterAcoustics\nusing Plots\n\nenv = UnderwaterEnvironment(bathymetry=20, seabed=SandyClay)\npm = PekerisRayTracer(env)\n\ntx = AcousticSource(0, -5, 1000)\nrx = AcousticReceiver(100, -10)\nrays = arrivals(pm, tx, rx)\n\nplot(env; xlims=(-10, 110))\nplot!(tx)\nplot!(rx)\nplot!(rays)\n\n\n\n\n\nrxs = AcousticReceiverGrid2D(1.0:0.1:100, -20:0.1:0)\nx = transmission_loss(pm, tx, rxs)\n\nplot(env; xlims=(0,100))\nplot!(rxs, x)",
    "crumbs": [
      "<b>Propagation models</b>",
      "PekerisRayTracer"
    ]
  },
  {
    "objectID": "kraken.html",
    "href": "kraken.html",
    "title": "Kraken",
    "section": "",
    "text": "Model\nAcousticsToolbox.Kraken\n\n\nDescription\nKraken and KrakenC normal mode models (wrapper)\n\n\nLanguage\nFortran\n\n\nAdvantages\nWell-established benchmark models\n\n\nLimitations\nNot differentiable\nA good overview of the Kraken model can be found at:",
    "crumbs": [
      "<b>Propagation models</b>",
      "Kraken"
    ]
  },
  {
    "objectID": "kraken.html#examples",
    "href": "kraken.html#examples",
    "title": "Kraken",
    "section": "Examples",
    "text": "Examples\n\nRange-independent scenario\nHere‚Äôs an example showing results for the PEKERIS test problem from the Kraken technical report:\n\nusing UnderwaterAcoustics\nusing AcousticsToolbox\nusing Plots\n\nenv = UnderwaterEnvironment(\n  bathymetry = 5000,\n  soundspeed = 1500,\n  density = 1000,\n  seabed = FluidBoundary(2000, 2000)\n)\npm = Kraken(env)\n\ntx = AcousticSource(0, -500, 10)\nrx = AcousticReceiver(200000, -2500)\nmodes = arrivals(pm, tx, rx)[1:7]     # first 7 modes\n\n7-element Vector{UnderwaterAcoustics.ModeArrival{ComplexF64, UnderwaterAcoustics.SampledFieldZ{Interpolations.Extrapolation{ComplexF64, 1, Interpolations.GriddedInterpolation{ComplexF64, 1, Vector{ComplexF32}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Tuple{Vector{Float32}}}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Interpolations.Flat{Nothing}}, Vector{Float32}}, Union{Missing, Float64}, Float64}}:\n   mode 1: k·µ£ = 0.041883 - 0.0im rad/m, v = 1499.84 m/s, v‚Çö = 1500.16 m/s\n   mode 2: k·µ£ = 0.04187 - 0.0im rad/m, v = 1499.36 m/s, v‚Çö = 1500.66 m/s\n   mode 3: k·µ£ = 0.041847 - 0.0im rad/m, v = 1498.56 m/s, v‚Çö = 1501.48 m/s\n   mode 4: k·µ£ = 0.041815 - 0.0im rad/m, v = 1497.45 m/s, v‚Çö = 1502.63 m/s\n   mode 5: k·µ£ = 0.041773 - 0.0im rad/m, v = 1496.01 m/s, v‚Çö = 1504.12 m/s\n   mode 6: k·µ£ = 0.041723 - 0.0im rad/m, v = 1494.24 m/s, v‚Çö = 1505.94 m/s\n   mode 7: k·µ£ = 0.041663 - 0.0im rad/m, v = 1492.15 m/s, v‚Çö = 1508.10 m/s\n\n\n\n# plot the modes\nplot(modes)\n\n\n\n\n\nrxs = AcousticReceiverGrid2D(200000:10:220000, -2500)\nx = transmission_loss(pm, tx, rxs)\n\nplot(200:0.01:220, x; ylims=(70,110), yflip=true, legend=false,\n  xlabel=\"Range (km)\", ylabel=\"Transmission loss (dB)\")\n\n\n\n\n\n\nRange-dependent scenario with multilayered seabed\nWhile the Kraken model is range-independent by itself, it can be made range-dependent by using AdiabaticExt as shown below:\n\nusing UnderwaterAcoustics\nusing Plots\n\nenv = UnderwaterEnvironment(\n  bathymetry = SampledField([200, 150, 200]; x=[0, 2000, 5000], interp=:linear),\n  soundspeed = 1500,\n  density = 1000,\n  seabed = MultilayerElasticBoundary([\n    (40, 1374, 1520, 0, dBperŒª(0.1124), 0),           # 40m thick fluid sediment\n    (Inf, 2200, 1730, 800, dBperŒª(0.5), dBperŒª(0.5))  # hard half-space substrate\n  ])\n)\n\n# use an adiabatic extension to the Kraken for range-dependence\npm = AdiabaticExt(Kraken, env)\n\ntx = AcousticSource(0, -50, 250)\nrx = AcousticReceiver(7000, -25)\nmodes = arrivals(pm, tx, rx)[1:7]      # first 7 modes\n\n7-element Vector{UnderwaterAcoustics.ModeArrival{ComplexF64, UnderwaterAcoustics.SampledFieldZ{Interpolations.Extrapolation{ComplexF64, 1, Interpolations.GriddedInterpolation{ComplexF64, 1, Vector{ComplexF32}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Tuple{Vector{Float32}}}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Interpolations.Flat{Nothing}}, Vector{Float32}}, Float64, Float64}}:\n   mode 1: k·µ£ = 1.047089 - 1.0e-6im rad/m, v = 1499.83 m/s, v‚Çö = 1500.16 m/s\n   mode 2: k·µ£ = 1.046762 - 3.0e-6im rad/m, v = 1499.30 m/s, v‚Çö = 1500.62 m/s\n   mode 3: k·µ£ = 1.046217 - 6.0e-6im rad/m, v = 1498.42 m/s, v‚Çö = 1501.41 m/s\n   mode 4: k·µ£ = 1.045452 - 1.0e-5im rad/m, v = 1497.19 m/s, v‚Çö = 1502.50 m/s\n   mode 5: k·µ£ = 1.044468 - 1.6e-5im rad/m, v = 1495.60 m/s, v‚Çö = 1503.92 m/s\n   mode 6: k·µ£ = 1.043263 - 2.2e-5im rad/m, v = 1493.65 m/s, v‚Çö = 1505.66 m/s\n   mode 7: k·µ£ = 1.041837 - 3.1e-5im rad/m, v = 1491.37 m/s, v‚Çö = 1507.72 m/s\n\n\n\n# plot the modes at 7 km range\nplot(modes)\nhline!([-200])    # seabed location\n\n\n\n\n\nrxs = AcousticReceiverGrid2D(10:10:7000, -200:1)\nx = transmission_loss(pm, tx, rxs)\n\nplot(rxs, x; crange=50)\nplot!(env)",
    "crumbs": [
      "<b>Propagation models</b>",
      "Kraken"
    ]
  },
  {
    "objectID": "kraken.html#notes",
    "href": "kraken.html#notes",
    "title": "Kraken",
    "section": "Notes",
    "text": "Notes\nThe Fortran Kraken propagation model requires that the transmitter is located at \\((x=0, y=0)\\) and all receivers are located in the right half-plane (i.e., \\(x&gt;0\\) and \\(y=0\\)). While this limitation can be worked around in the wrapper by a coordinate transformation, automatic transformation is not yet implemented.\nAdditionally, this wrapper does not yet support all the features of the original Fortran model. In particular, it does NOT support:\n\nN2-linear, analytic or quadratic interpolation for sound speed\nArbitrary reflection coefficients\nTwersky scattering\n\nReceivers on an irregular grid are supported, but not currently optimized for speed (by using the irregular grid option in the Fortran model).\nKraken currently does not compute modal group velocities. While KrakenC does compute group velocities, the values are incorrect for multilayer seabeds with elastic sediment layers. In both cases, when group velocities are unavailable, the returned modes will not include group velocity information (will be reported as missing).",
    "crumbs": [
      "<b>Propagation models</b>",
      "Kraken"
    ]
  },
  {
    "objectID": "fields.html",
    "href": "fields.html",
    "title": "Range and depth dependence",
    "section": "",
    "text": "When describing underwater environments, we often need to work with quantities that vary with position. Some quantities are constant, while others may vary with depth, range, or 3D position (e.g.¬†sound speed profile, bathymetry, etc). We introduce a consistent representation of fields to help formalize position-dependent quantities.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Range and depth dependence"
    ]
  },
  {
    "objectID": "fields.html#interface",
    "href": "fields.html#interface",
    "title": "Range and depth dependence",
    "section": "Interface",
    "text": "Interface\nFields that do not vary with position are considered constant, and are represented by scalars. If a field may vary only with depth, but not with horizontal position, it is considered DepthDependent. On the other hand, if it may vary with any positional coordinate, it is considered PositionDependent. Varying fields are represented by data types that are subtypes of the appropriate abstract type (DepthDependent or PositionDependent).\n\n\n\n\n\n\nDepthDependent\nQuantity that may vary with depth, but not with range (x or y coordinate).\n\n\n\n\n\n\n\n\n\nPositionDependent\nQuantity that may vary with depth and range (x, y and/or z coordinate).\n\n\n\nTo get the value of a field at a given position, we use the value function:\n\n\n\n\n\n\nvalue(q)\nvalue(q, pos)\nGet the value of the varying quantity q at the given position pos. pos may be specified as a (x, y, z) tuple, a (x, z) tuple, or a z value.\n\nExamples\nvalue(q)             # get value of a constant quantity\nvalue(q, -10)        # get value of a depth-dependent quantity at z=-10\nvalue(q, (1000,-10)) # get value of a position-dependent quantity at x=1000, z=-10\nvalue(q, (0,0,-10))  # get value of a position-dependent quantity at (0,0,-10)\n\n\n\n\nWe can also check if a field is constant or range-dependent:\n\n\n\n\n\n\nis_constant(q)\nReturn true if the quantity q is a constant, false if it could depend on position.\n\n\n\n\n\n\n\n\n\nis_range_dependent(q)\nReturn true if the quantity q may be range-dependent, false if it is guaranteed to not depend on x or y coordinate.\n\n\n\nFields that only vary with depth are neither constant nor range-dependent.\nSome propagation models require knowledge of the extreme values of a field. These can be obtained using the minimum and maximum functions:\n\n\n\n\n\n\nminimum(q)\nGet the minimum value of a field quantity q.\n\n\n\n\n\n\n\n\n\nmaximum(q)\nGet the maximum value of a field quantity q.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Range and depth dependence"
    ]
  },
  {
    "objectID": "fields.html#implementations",
    "href": "fields.html#implementations",
    "title": "Range and depth dependence",
    "section": "Implementations",
    "text": "Implementations\n\nConstants\nScalars are trivially constant fields:\n\nlet q = 1500\n  @show q\n  @show is_constant(q)\n  @show is_range_dependent(q)\n  @show value(q)\n  @show value(q, -10)\n  @show value(q, (1000, -10))\n  @show value(q, (0, 0, -10))\n  @show minimum(q)\n  @show maximum(q)\nend;\n\nq = 1500\nis_constant(q) = true\nis_range_dependent(q) = false\nvalue(q) = 1500\nvalue(q, -10) = 1500\nvalue(q, (1000, -10)) = 1500\nvalue(q, (0, 0, -10)) = 1500\nminimum(q) = 1500\nmaximum(q) = 1500\n\n\nThey can be used in environmental descriptions. For example, iso-velocity environments can be described using a constant sound speed:\nenv = UnderwaterEnvironment(soundspeed=1500)\n\n\nSampled fields\nPosition-dependent fields can be defined using data samples at a set of positions. Values at other positions are obtained by interpolation. The SampledField() function creates a sampled field from a set of data samples:\n\n\n\n\n\n\nSampledField(v; x)\nSampledField(v; z)\nSampledField(v; x, y)\nSampledField(v; x, z)\nSampledField(v; x, y, z)\nCreate a sampled field from a data v that may depend on position. For 1D fields, the x or z coordinate is required, and v is a vector. For 2D fields, the x and y coordinates or the x and z coordinates are required, and v is a matrix. For 3D fields, the x, y, and z coordinates are required, and v is a 3D array.\nKeyword argument interp is used to specify the interpolation method. :linear interpolation is supported for 1D, 2D and 3D fields. For 2D and 3D fields, the data must be sampled on a regular grid. For uniformly sampled 1D fields, :cubic interpolation is also supported.\n\n\n\nWe can understand how to use SampledField by looking at some examples. Let‚Äôs create an environment with a depth-dependent sound speed profile:\n\nenv = UnderwaterEnvironment(\n  soundspeed = SampledField([1500, 1520]; z=[0, -100])\n)\n\nlet q = env.soundspeed\n  @show q\n  @show is_constant(q)\n  @show is_range_dependent(q)\n  @show value(q, 0)\n  @show value(q, -50)\n  @show value(q, -100)\n  @show value(q, (1000, -50))\n  @show value(q, (0, 0, -50))\n  @show minimum(q)\n  @show maximum(q)\n  plot(q)\nend\n\nq = SampledField(z-varying, 2 samples)\nis_constant(q) = false\nis_range_dependent(q) = false\nvalue(q, 0) = 1500.0\nvalue(q, -50) = 1510.0\nvalue(q, -100) = 1520.0\nvalue(q, (1000, -50)) = 1510.0\nvalue(q, (0, 0, -50)) = 1510.0\nminimum(q) = 1500.0\nmaximum(q) = 1520.0\n\n\n\n\n\nThe default interpolation method is linear, but we can use cubic interpolation by specifying interp=:cubic:\n\nplot(SampledField([1500, 1490, 1520]; z=0:-10:-20))\nplot!(SampledField([1500, 1490, 1520]; z=0:-10:-20, interp=:cubic))\n\n\n\n\nAnother example is a range-dependent bathymetry:\n\nenv = UnderwaterEnvironment(\n  bathymetry = SampledField([100, 110, 105, 110]; x=[0, 1000, 1500, 2000])\n)\n\nplot(env; xlims=(0,2000))\n\n\n\n\n2D and 3D sampled fields can be created by specifying the x, y, and z coordinates. For example, a 2D field can be created using:\n\nlet q = SampledField([0.0 1.0; 1.0 2.0]; x=[0.0, 20.0], y=[0.0, 20.0])\n  @show q\n  @show is_constant(q)\n  @show is_range_dependent(q)\n  @show value(q, (10, 10, 0))\n  @show value(q, (10, 10, -10))\n  @show minimum(q)\n  @show maximum(q)\n  plot(q)\nend\n\nq = SampledField(xy-varying, 2√ó2 samples)\nis_constant(q) = false\nis_range_dependent(q) = true\nvalue(q, (10, 10, 0)) = 1.0\nvalue(q, (10, 10, -10)) = 1.0\nminimum(q) = 0.0\nmaximum(q) = 2.0\n\n\n\n\n\n\n\nCustom fields\nWe may define a custom field type by subtyping DepthDependent or PositionDependent. For example, we can define a Munk sound speed profile:\n\nstruct MunkSSP &lt;: UnderwaterAcoustics.DepthDependent end\n\nfunction (::MunkSSP)(pos)\n  œµ = 0.00737\n  zÃÉ = 2.0 * (-pos.z - 1300.0) / 1300.0\n  1500.0 * (1.0 + œµ * (zÃÉ - 1 + exp(-zÃÉ)))\nend\n\nBase.minimum(::MunkSSP) = 1500.0    # 1.3 km depth\nBase.maximum(::MunkSSP) = 1654.0    # 11 km depth (maximum depth of the ocean)\n\nlet q = MunkSSP()\n  @show q\n  @show is_constant(q)\n  @show is_range_dependent(q)\n  @show value(q, -1300)\n  @show value(q, (100, 100, -1500))\n  @show minimum(q)\n  @show maximum(q)\n  plot(q, -11000:0; xlabel=\"Sound speed (m/s)\")\nend\n\nq = Main.Notebook.MunkSSP()\nis_constant(q) = false\nis_range_dependent(q) = false\nvalue(q, -1300) = 1500.0\nvalue(q, (100, 100, -1500)) = 1500.4735275294795\nminimum(q) = 1500.0\nmaximum(q) = 1654.0",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Range and depth dependence"
    ]
  },
  {
    "objectID": "api.html",
    "href": "api.html",
    "title": "Propagation & channel modeling",
    "section": "",
    "text": "API reference",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "api.html#environment-models",
    "href": "api.html#environment-models",
    "title": "Propagation & channel modeling",
    "section": "Environment models",
    "text": "Environment models\n\n\n\n\n\n\nUnderwaterEnvironment(; kwargs...)\nCreate a generic underwater environment with the given parameters. The following parameters are supported:\n\nbathymetry = bathymetry model\naltimetry = altimetry model\ntemperature = temperature model\nsalinity = salinity model\npH = pH model\nsoundspeed = sound speed profile model\ndensity = density model\nseabed = seabed sediment model\nsurface = surface model\n\nAll parameters are optional and have default values.\n\n\n\n\n\n\n\n\n\nis_range_dependent(env)\nReturn true if any quantity (e.g.¬†sound speed, bathymetry, etc) in the environment env depends on the horizontal location, and false otherwise.\n\n\n\n\n\n\n\n\n\nis_isovelocity(env)\nReturn true if the sound speed in the environment env is a constant.\n\n\n\n\n\n\n\n\n\nenv_type(env)\nReturn the base number type for the environment. Typically, this is a Float64, but could differ if the environment was constructed using other number types.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "api.html#propagation-models",
    "href": "api.html#propagation-models",
    "title": "Propagation & channel modeling",
    "section": "Propagation models",
    "text": "Propagation models\n\n\n\n\n\n\nmodels()\nmodels(mtype::Type{&lt;:AbstractPropagationModel})\nReturn a list of all available propagation models. If mtype is specified, return only models of that type.\n\n\n\n\n\n\n\n\n\nPekerisRayTracer(env; max_bounces=3)\nA fast differentiable ray tracer that only supports iso-velocity constant depth environments. max_bounces is the number of surface/bottom bounces to consider in the ray tracing.\n\n\n\n\n\n\n\n\n\nPekerisModeSolver(env; ngrid=0, nmodes=0)\nA fast differentiable mode propagation model that only supports iso-velocity constant depth environments.\nngrid is the number of grid points to use for modal root finding for fluid bottom environments. If ngrid is too small, the mode solver may miss some modes. If ngrid is too large, the mode solver may take a long time to converge. The default value of ngrid of 0 will use a heuristic to automatically determine the number of grid points to use.\nnmodes controls the maximum number of modes computed. Setting nmodes to 0 causes all propagating modes to be computed.\n\n\n\n\n\n\n\n\n\nAdiabaticExt(model, env; dx=0.0, dz=0.0, reciprocal=false, kwargs...)\nA 2D adiabatic mode propagation model based on a range-independent modal propagation model. The adiabatic mode model supports range-dependent bathymetry. Any kwargs passed in are transferred to the underlying model.\ndx is the step size in the range direction for integration. dz is the mesh size in the depth direction to compute modes. If dx and/or dz is set to zero, it is automatically determined (~10 points per wavelength).\nAdiabatic mode models are usually not reciprocal, i.e., exchanging a source and receiver changes the answer. This is because the bathymetry is assumed to have azimuthal symmetry around the source. In reciprocal mode, the adiabatic computation is modified to ensure reciprocity, but azimuthal symmetry is lost.\n\n\n\n\n\n\n\n\n\nRayArrival\nType representing a single acoustic ray arrival.\nProperties:\n\nt / time: arrival time (s)\nœï / phasor: complex amplitude\nns / surface_bounces: number of surface bounces\nnb / bottom_bounces: number of bottom bounces\nŒ∏‚Çõ / launch_angle: launch angle at source (rad)\nŒ∏·µ£ / arrival_angle: arrival angle at receiver (rad)\npath: ray path (optional, vector of 3-tuples or missing)\n\nThe properties are accessible with the short names for brevity, and longer more descriptive names where readability is desired or unicode symbols are undesired.\n\n\n\n\n\n\n\n\n\nModeArrival\nType representing a single acoustic mode arrival.\nProperties:\n\nm / mode: mode number\nk·µ£ / hwavenumber: horizontal wavenumber (rad/m)\nœà(z) / mode_function: mode function\nv / group_velocity: group velocity (m/s)\nv‚Çö / phase_velocity: phase velocity (m/s)\n\nThe properties are accessible with the short names for brevity, and longer more descriptive names where readability is desired or unicode symbols are undesired.\n\n\n\n\n\n\n\n\n\narrivals(pm, tx, rx; paths=true)\nCompute the arrivals at the receiver rx due to the source tx using propagation model pm. Returns an array of arrivals.\nFor ray models, eigenray paths are typically included in the arrivals. However, if they are not needed, one may set paths=false to allow the propagation model to avoid computing them.\n\n\n\n\n\n\n\n\n\nacoustic_field(pm, tx, rxs)\nCompute the acoustic field at the receivers rxs due to the source tx using propagation model pm. If rxs denotes a single receiver, the result is a complex scalar. If rxs is an AbstractArray, the result is an array of complex numbers with the same shape as rxs. The amplitude of the field is related to the transmission loss, and the angle is related to the acoustic phase at the source frequency.\nacoustic_field(pm::PekerisRayTracer, tx, rxs; mode=:coherent)\nCompute the acoustic field at a receiver rxs due to a transmitter tx in the Pekeris waveguide. The field is computed incoherently if mode=:incoherent. Otherwise, the field is computed coherently.\nacoustic_field(pm::PekerisModeSolver, tx, rxs; mode=:coherent)\nCompute the acoustic field at a receiver rxs due to a transmitter tx in the Pekeris waveguide. The field can be computed incoherently if mode=:incoherent. Otherwise, the field is computed coherently.\n\n\n\n\n\n\n\n\n\ntransmission_loss(pm, tx, rxs)\nCompute the transmission loss from the source tx to the receivers rxs using propagation model pm. If rxs denotes a single receiver, the result is a scalar. If rxs is an AbstractArray, the result is an array of transmission losses (in dB) with the same shape as rxs.\n\n\n\n\n\n\n\n\n\nimpulse_response(pm, tx, rx, fs; abstime=false, ntaps=nothing)\nCompute the impulse response at the receiver rx due to the source tx using propagation model pm at the given sampling frequency fs. If abstime is true, the result is in absolute time from the start of transmission. Otherwise, the result is relative to the earliest arrival time of the signal at the receiver (possibly with some guard period to accommodate acausal response). ntaps specifies the number of taps in the impulse response. If not specified, the number of taps is chosen automatically based on the arrival times.\nimpulse_response(pm::AbstractModePropagationModel, tx, rx, fs; abstime, ntaps, fmin, fmax)\nCompute the impulse response at the receiver rx due to the source tx using propagation model pm at the given sampling frequency fs.\nIf abstime is true (default is false), the result is in absolute time from the start of transmission. Otherwise, the result is relative to the earliest arrival time of the signal at the receiver (with some guard period to accommodate acausal response).\nntaps specifies the number of taps in the impulse response. If not specified, the number of taps is chosen automatically based on the arrival times.\nfmin and fmax specifies the bandwidth of interest. If unspecified, a 50% bandwidth is assumed, i.e., if the transmitter frequency is 300 Hz the bandwidth of interest is assumed to be 150 Hz (fmin = 225, fmax = 375). Larger bandwidths require more modal computations, and hence increase computational load.\nThe impulse response is computed only for positive frequencies. Such an impulse response is suitable for convolution with passband complex analytic signals. If convolved with real signals, the resulting signal is approximately equivalent to converting the real signal to a complex analytic form and then convolving it with the impulse response.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "api.html#channel-models-and-simulation",
    "href": "api.html#channel-models-and-simulation",
    "title": "Propagation & channel modeling",
    "section": "Channel models and simulation",
    "text": "Channel models and simulation\n\n\n\n\n\n\nchannel(pm, txs, rxs, fs; noise=nothing)\nCompute a channel model from the sources txs to the receivers rxs using propagation model pm. The result is a channel model with the same number of input channels as the number of sources and output channels as the number of receivers. The channel model accepts signals sampled at rate fs and returns signals sampled at the same rate.\nAn additive noise model may be optionally specified as noise. If specified, it is used to corrupt the received signals.\n\n\n\n\n\n\n\n\n\nBasebandReplayChannel(h, Œ∏, fs, fc, step=1; noise=nothing)\nBasebandReplayChannel(h, fs, fc, step=1; noise=nothing)\nConstruct a baseband replay channel with impulse responses h and phase estimates Œ∏. The phase estimates are optional. fs is the sampling frequency in Sa/s, fc is the carrier frequency in Hz, and step is the decimation rate for the time axis of h. The effective sampling frequency of the impulse responses is fs √∑ step impulse responses per second.\nAn additive noise model may be optionally specified as noise. If specified, it is used to corrupt the received signals.\nBasebandReplayChannel(filename; upsample=false, rxs=:, noise=nothing)\nLoad a baseband replay channel from a file.\nIf upsample is true, the impulse responses are upsampled to the delay axis sampling rate. This makes applying the channel faster but requires more memory. rxs controls which receivers to load from the file. By default, all receivers are loaded.\nAn additive noise model may be optionally specified as noise. If specified, it is used to corrupt the received signals.\nSupported formats:\n\n.mat (MATLAB) file in underwater acoustic channel repository (UACR) format. See https://github.com/uwa-channels/ for details.\n\n\n\n\n\n\n\n\n\n\ntransmit(ch, x; txs=:, rxs=:, abstime=false, noisy=true, fs=nothing)\nSimulate the transmission of passband signal x through the channel model ch. If txs is specified, it specifies the indices of the sources active in the simulation. The number of sources must match the number of channels in the input signal. If rxs is specified, it specifies the indices of the receivers active in the simulation. Returns the received signal at the specified (or all) receivers.\nfs specifies the sampling rate of the input signal. The output signal is sampled at the same rate. If fs is not specified but x is a SampledSignal, the sampling rate of x is used. Otherwise, the signal is assumed to be sampled at the channel‚Äôs sampling rate.\nIf abstime is true, the returned signals begin at the start of transmission. Otherwise, the result is relative to the earliest arrival time of the signal at any receiver. If noisy is true and the channel has a noise model associated with it, the received signal is corrupted by additive noise.\ntransmit(ch::BasebandReplayChannel, x; rxs=:, abstime=false, noisy=true, fs=nothing, start=nothing)\nSimulate the transmission of passband signal x through the channel model ch. If txs is specified, it specifies the indices of the sources active in the simulation. The number of sources must match the number of channels in the input signal. If rxs is specified, it specifies the indices of the receivers active in the simulation. Returns the received signal at the specified (or all) receivers.\nfs specifies the sampling rate of the input signal. The output signal is sampled at the same rate. If fs is not specified but x is a SampledSignal, the sampling rate of x is used. Otherwise, the signal is assumed to be sampled at the channel‚Äôs sampling rate.\nIf abstime is true, the returned signals begin at the start of transmission. Otherwise, the result is relative to the earliest arrival time of the signal at any receiver. If noisy is true and the channel has a noise model associated with it, the received signal is corrupted by additive noise.\nIf start is specified, it specifies the starting time index in the replay channel. If not specified, a random start time is chosen.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "api.html#boundary-conditions",
    "href": "api.html#boundary-conditions",
    "title": "Propagation & channel modeling",
    "section": "Boundary conditions",
    "text": "Boundary conditions\n\n\n\n\n\n\nreflection_coef(Œ∏, œÅ·µ£, c·µ£, c·µ£‚Çõ, Œ¥, Œ¥‚Çõ)\nCompute complex reflection coefficient at a fluid-solid boundary, given:\n\nangle of incidence Œ∏ (angle to the surface normal)\nrelative density of the reflecting medium to incidence medium œÅ·µ£\nrelative compressional sound speed of the reflecting medium to incidence medium c·µ£\nrelative shear sound speed of the reflecting medium to incidence medium c·µ£‚Çõ\ndimensionless compressional absorption coefficient Œ¥\ndimensionless shear absorption coefficient Œ¥‚Çõ\n\nWARNING: Fluid-solid reflection not implemented. Currently ignores shear.\n\n\n\n\n\n\n\n\n\nPressureReleaseBoundary\nPressure-release boundary condition.\n\n\n\n\n\n\n\n\n\nRigidBoundary\nRigid boundary condition.\n\n\n\n\n\n\n\n\n\nFluidBoundary(œÅ, c, Œ¥=0, œÉ=0)\nCreate a fluid half-space boundary with density œÅ, sound speed c, dimensionless absorption coefficient Œ¥, and interfacial roughness œÉ.\n\nExamples\njulia&gt; FluidBoundary(1200, 1500)\nFluidBoundary(œÅ=1200.0, c=1500.0)\n\njulia&gt; FluidBoundary(1200, 1500, 0.1)\nFluidBoundary(œÅ=1200.0, c=1500.0, Œ¥=0.1)\n\njulia&gt; FluidBoundary(1200, 1500, 0.1, 0.1)\nFluidBoundary(œÅ=1200.0, c=1500.0, Œ¥=0.1, œÉ=0.1)\n\njulia&gt; FluidBoundary(œÅ=1200, c=1500)\nFluidBoundary(œÅ=1200.0, c=1500.0)\n\njulia&gt; FluidBoundary(œÅ=1200, c=1500, Œ¥=0.1, œÉ=0.1)\nFluidBoundary(œÅ=1200.0, c=1500.0, Œ¥=0.1, œÉ=0.1)\n\njulia&gt; FluidBoundary(œÅ=1200.0, c=0.0)\nPressureReleaseBoundary\n\njulia&gt; FluidBoundary(œÅ=1200.0, c=Inf)\nRigidBoundary\n\njulia&gt; FluidBoundary(1.2u\"g/cm^3\", 1500u\"m/s\")\nFluidBoundary(œÅ=1200.0, c=1500.0)\n\n\n\n\n\n\n\n\n\n\nElasticBoundary(œÅ, c‚Çö, c‚Çõ)\nElasticBoundary(œÅ, c‚Çö, c‚Çõ, Œ¥‚Çö, Œ¥‚Çõ)\nElasticBoundary(œÅ, c‚Çö, c‚Çõ, Œ¥‚Çö, Œ¥‚Çõ, œÉ)\nCreate a solid half-space boundary with density œÅ, compressional sound speed c‚Çö, shear sound speed c‚Çõ, dimensionless compressional absorption coefficient Œ¥‚Çö, dimensionless shear absorption coefficient Œ¥‚Çõ, and interfacial roughness œÉ. If the absorption coefficients or interfacial roughness are unspecified, they are assumed to be 0.\n\nExamples\njulia&gt; ElasticBoundary(1200, 1500, 500)\nElasticBoundary(œÅ=1200.0, c‚Çö=1500.0, c‚Çõ=500.0)\n\njulia&gt; ElasticBoundary(1200, 1500, 500, 0.1, 0.2)\nElasticBoundary(œÅ=1200.0, c‚Çö=1500.0, c‚Çõ=500.0, Œ¥‚Çö=0.1, Œ¥‚Çõ=0.2)\n\njulia&gt; ElasticBoundary(1200, 1500, 500, 0.1, 0.2, 0.1)\nElasticBoundary(œÅ=1200.0, c‚Çö=1500.0, c‚Çõ=500.0, Œ¥‚Çö=0.1, Œ¥‚Çõ=0.2, œÉ=0.1)\n\njulia&gt; ElasticBoundary(œÅ=1200, c‚Çö=1500, c‚Çõ=500)\nElasticBoundary(œÅ=1200.0, c‚Çö=1500.0, c‚Çõ=500.0)\n\njulia&gt; ElasticBoundary(œÅ=1200, c‚Çö=1500, c‚Çõ=500, Œ¥‚Çö=0.1, Œ¥‚Çõ=0.2)\nElasticBoundary(œÅ=1200.0, c‚Çö=1500.0, c‚Çõ=500.0, Œ¥‚Çö=0.1, Œ¥‚Çõ=0.2)\n\njulia&gt; ElasticBoundary(œÅ=1200, c‚Çö=1500, c‚Çõ=500, Œ¥‚Çö=0.1, Œ¥‚Çõ=0.2, œÉ=0.1)\nElasticBoundary(œÅ=1200.0, c‚Çö=1500.0, c‚Çõ=500.0, Œ¥‚Çö=0.1, Œ¥‚Çõ=0.2, œÉ=0.1)\n\njulia&gt; ElasticBoundary(1.2u\"g/cm^3\", 1500u\"m/s\", 500u\"m/s\")\nElasticBoundary(œÅ=1200.0, c‚Çö=1500.0, c‚Çõ=500.0)\n\n\n\n\n\n\n\n\n\n\nMultilayerElasticBoundary([(h, œÅ, c‚Çö, c‚Çõ), ...])\nMultilayerElasticBoundary([(h, œÅ, c‚Çö, c‚Çõ, Œ¥‚Çö, Œ¥‚Çõ), ...])\nMultilayerElasticBoundary([(h, œÅ, c‚Çö, c‚Çõ, Œ¥‚Çö, Œ¥‚Çõ, œÉ), ...])\nCreate a multilayer solid boundary with layers defined by a vector of tuples specifying the layer thickness h, density œÅ, compressional sound speed c‚Çö, shear sound speed c‚Çõ, dimensionless compressional absorption coefficient Œ¥‚Çö, dimensionless shear absorption coefficient Œ¥‚Çõ, and interfacial roughness œÉ for each layer. If the absorption coefficients or interfacial roughness is unspecified, they are assumed to be 0. The last entry in the vector is considered the bottom half-space and has an infinite thickness. By convention, we specify a value of Inf for h for that layer.\nœÅ, c‚Çö, and c‚Çõ may also be specified with linear variation within a layer by specifying the value as a 2-tuple, with the first entry being the value at the top of the layer and the second entry being the value at the bottom.\n\nExamples\njulia&gt; MultilayerElasticBoundary([\n         (5.2, 1300, 1700, 100),\n         (Inf, 2000, 2500, 500, 0.1, 0.2)\n       ])\nMultilayerElasticBoundary(2 layers):\n  (h = 5.2, œÅ = 1300.0, c‚Çö = 1700.0, c‚Çõ = 100.0, Œ¥‚Çö = 0.0, Œ¥‚Çõ = 0.0, œÉ = 0.0)\n  (h = Inf, œÅ = 2000.0, c‚Çö = 2500.0, c‚Çõ = 500.0, Œ¥‚Çö = 0.1, Œ¥‚Çõ = 0.2, œÉ = 0.0)\n\njulia&gt; MultilayerElasticBoundary([\n         (5.2, 1300, (1700,2000), 100),\n         (Inf, 2000, 2500, 500, 0.1, 0.2)\n       ])\nMultilayerElasticBoundary(2 layers):\n  (h = 5.2, œÅ = 1300.0, c‚Çö = (1700.0, 2000.0), c‚Çõ = 100.0, Œ¥‚Çö = 0.0, Œ¥‚Çõ = 0.0, œÉ = 0.0)\n  (h = Inf, œÅ = 2000.0, c‚Çö = 2500.0, c‚Çõ = 500.0, Œ¥‚Çö = 0.1, Œ¥‚Çõ = 0.2, œÉ = 0.0)\n\njulia&gt; MultilayerElasticBoundary([\n         (5.2, 1300, 1700, 100, 0, 0, 0.1),\n         (Inf, 2000, 2500, 500, 0.1, 0.2, 0.1)\n       ])\nMultilayerElasticBoundary(2 layers):\n  (h = 5.2, œÅ = 1300.0, c‚Çö = 1700.0, c‚Çõ = 100.0, Œ¥‚Çö = 0.0, Œ¥‚Çõ = 0.0, œÉ = 0.1)\n  (h = Inf, œÅ = 2000.0, c‚Çö = 2500.0, c‚Çõ = 500.0, Œ¥‚Çö = 0.1, Œ¥‚Çõ = 0.2, œÉ = 0.1)\n\njulia&gt; MultilayerElasticBoundary([\n         (h = 5.2, œÅ = 1300, c‚Çö = 1700, c‚Çõ = 100, Œ¥‚Çö = 0.1, Œ¥‚Çõ = 0.2, œÉ = 0.1),\n         (h = Inf, œÅ = 2000, c‚Çö = 2500, c‚Çõ = 500)\n       ])\nMultilayerElasticBoundary(2 layers):\n  (h = 5.2, œÅ = 1300.0, c‚Çö = 1700.0, c‚Çõ = 100.0, Œ¥‚Çö = 0.1, Œ¥‚Çõ = 0.2, œÉ = 0.1)\n  (h = Inf, œÅ = 2000.0, c‚Çö = 2500.0, c‚Çõ = 500.0, Œ¥‚Çö = 0.0, Œ¥‚Çõ = 0.0, œÉ = 0.0)\n\njulia&gt; MultilayerElasticBoundary([\n         (5.2u\"m\", 1.3u\"g/cm^3\", 1700u\"m/s\", 100u\"m/s\", 0.1, 0.2),\n         (Inf, 2u\"g/cm^3\", 2500u\"m/s\", 500u\"m/s\")\n       ])\nMultilayerElasticBoundary(2 layers):\n  (h = 5.2, œÅ = 1300.0, c‚Çö = 1700.0, c‚Çõ = 100.0, Œ¥‚Çö = 0.1, Œ¥‚Çõ = 0.2, œÉ = 0.0)\n  (h = Inf, œÅ = 2000.0, c‚Çö = 2500.0, c‚Çõ = 500.0, Œ¥‚Çö = 0.0, Œ¥‚Çõ = 0.0, œÉ = 0.0)\n\n\n\n\n\n\n\n\n\n\nWindySurface(windspeed)\nReflection model for a water surface affected by wind. windspeed is given in m/s.\n\n\n\n\n\n\n\n\n\nPre-defined boundary conditions based on APL-UW Technical Report 9407:\n# sea surface boundary conditions\nconst SeaState0    = WindySurface(0.8)\nconst SeaState1    = WindySurface(2.6)\nconst SeaState2    = WindySurface(4.4)\nconst SeaState3    = WindySurface(6.9)\nconst SeaState4    = WindySurface(9.8)\nconst SeaState5    = WindySurface(12.6)\nconst SeaState6    = WindySurface(19.3)\nconst SeaState7    = WindySurface(26.5)\nconst SeaState8    = WindySurface(30.6)\nconst SeaState9    = WindySurface(32.9)\n# seabed boundary conditions\nconst Rock         = FluidBoundary(2557.5, 3820.0, 0.01374)\nconst Pebbles      = FluidBoundary(2557.5, 2750.4, 0.01374)\nconst SandyGravel  = FluidBoundary(2547.8, 2041.6, 0.01705)\nconst CoarseSand   = FluidBoundary(2282.3, 1911.1, 0.01638)\nconst MediumSand   = FluidBoundary(1886.8, 1799.5, 0.01624)\nconst FineSand     = FluidBoundary(1483.5, 1690.7, 0.01602)\nconst VeryFineSand = FluidBoundary(1297.8, 1613.4, 0.01875)\nconst ClayeySand   = FluidBoundary(1251.0, 1581.3, 0.02019)\nconst CoarseSilt   = FluidBoundary(1222.1, 1553.3, 0.02158)\nconst SandySilt    = FluidBoundary(1195.0, 1525.9, 0.01261)\nconst Silt         = FluidBoundary(1175.1, 1508.1, 0.00386)\nconst FineSilt     = FluidBoundary(1173.8, 1506.3, 0.00306)\nconst SandyClay    = FluidBoundary(1172.5, 1504.6, 0.00242)\nconst SiltyClay    = FluidBoundary(1171.2, 1501.7, 0.00163)\nconst Clay         = FluidBoundary(1169.8, 1498.4, 0.00148)",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "api.html#sources-and-receivers",
    "href": "api.html#sources-and-receivers",
    "title": "Propagation & channel modeling",
    "section": "Sources and receivers",
    "text": "Sources and receivers\n\n\n\n\n\n\nAcousticSource(pos, frequency; spl=0)\nAcousticSource(x, z, frequency; spl=0)\nAcousticSource(x, y, z, frequency; spl=0)\nAn source at location pos with nominal frequency and source level spl (dB re 1 ¬µPa @ 1 m). The source is assumed to be omnidirectional and well approximated by a point source. While the source may have some bandwidth, the nominal frequency is used to estimate propagation effects such as absorption, reflection coefficients, etc.\nIf the location of the source is unknown, it may be specified as nothing. This is useful when the propagation model does not require the source location (e.g., data-driven models).\n\n\n\n\n\n\n\n\n\nAcousticReceiver(pos)\nAcousticReceiver(x, z)\nAcousticReceiver(x, y, z)\nReceiver at location pos.\n\n\n\n\n\n\n\n\n\nAcousticReceiverGrid2D(xrange, zrange)\nA 2D grid of receivers with the specified location ranges.\n\n\n\n\n\n\n\n\n\nAcousticReceiverGrid3D(xrange, yrange, zrange)\nA 3D grid of receivers with the specified location ranges.\n\n\n\n\n\n\n\n\n\nlocation(tx::AbstractAcousticSource)\nlocation(rx::AbstractAcousticReceiver)\nGet the location of the source or receiver.\n\n\n\n\n\n\n\n\n\nfrequency(tx::AbstractAcousticSource)\nGet the nominal frequency of an acoustic source.\n\n\n\n\n\n\n\n\n\nspl(tx::AbstractAcousticSource)\nGet the source level of an acoustic source.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "api.html#noise-models",
    "href": "api.html#noise-models",
    "title": "Propagation & channel modeling",
    "section": "Noise models",
    "text": "Noise models\n\n\n\n\n\n\nWhiteGaussianNoise(œÉ)\nWhiteGaussianNoise(psd, fs)\nCreate a white Gaussian ambient noise model with variance œÉ¬≤ ¬µPa¬≤ or with power spectral density psd ¬µPa¬≤/Hz and bandwidth fs/2 Hz.\n\n\n\n\n\n\n\n\n\nRedGaussianNoise(œÉ)\nCreate an ambient noise model with variance œÉ¬≤ ¬µPa¬≤ and 1/f¬≤ variation in power spectral density.\n\n\n\n\n\n\n\n\n\nrand([rng::AbstractRNG, ] noise::AbstractNoiseModel, nsamples; fs)\nrand([rng::AbstractRNG, ] noise::AbstractNoiseModel, nsamples, nchannels; fs)\nGenerate random noise samples from the noise model noise with the specified size nsamples (can be a 2-tuple for multichannel noise). The noise is returned as a signal sampled at fs. The optional rng argument specifies the random number generator to use.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "basic.html",
    "href": "basic.html",
    "title": "Underwater acoustics",
    "section": "",
    "text": "API reference\n\n\n\n\n\n\nsoundspeed(temperature=27, salinity=35, depth=0; Œ≥=0, c‚Çê=340, œÅ·µ£=1000)\nCompute sound speed in water in m/s, given:\n\nwater temperature in ¬∞C\nsalinity in ppt\ndepth in meters\nvoid fraction (Œ≥) in bubbly water\nsound speed in gas (c‚Çê) if Œ≥ &gt; 0\nratio of density of water to gas (œÅ·µ£) if Œ≥ &gt; 0\n\nImplementation based on Mackenzie (1981), Wood (1964) and Buckingham (1997).\n\n\n\n\n\n\n\n\n\nabsorption(frequency, distance=1000, salinity=35, temperature=27, depth=0, pH=8.1)\nCompute volume acoustic absorption coefficient in water, given:\n\nfrequency in Hz\ndistance in meters\nsalinity in ppt\nwater temperature in ¬∞C\ndepth in meters\npH of water\n\nThe result is a unitless linear scale factor for sound pressure over the given distance. To get absorption in terms of dB / m, set distance = 1.0 and convert the result to decibels. For instance, at a frequency of 100 kHz:\njulia&gt; A = absorption(100e3, 1.0)\n0.9959084838594522\n\njulia&gt; Œ± = -20log10(A)\n0.035611359656810865\nImplementation based on the Francois and Garrison (1982) model.\n\n\n\n\n\n\n\n\n\nwater_density(temperature=27, salinity=35)\nCompute density of water (kg/m¬≥), given temperature in ¬∞C and salinity in ppt.\nImplementation based on Fofonoff (1985 - IES 80).\n\n\n\n\n\n\n\n\n\ndBperŒª(x)\nCompute dimensionless absorption coefficient Œ¥ from dB/Œª. Implementation based on APL-UW TR 9407 (1994), IV-9 equation (4).\n\n\n\n\n\n\n\n\n\nin_dBperŒª(Œ¥)\nCompute dB/Œª from dimensionless absorption coefficient Œ¥. Implementation based on APL-UW TR 9407 (1994), IV-9 equation (4).\n\n\n\n\n\n\n\n\n\nreflection_coef(Œ∏, œÅ·µ£, c·µ£, Œ¥=0.0)\nCompute complex reflection coefficient at a fluid-fluid boundary, given:\n\nangle of incidence Œ∏ (angle to the surface normal)\nrelative density of the reflecting medium to incidence medium œÅ·µ£\nrelative sound speed of the reflecting medium to incidence medium c·µ£\ndimensionless absorption coefficient Œ¥\n\nImplementation based on Brekhovskikh & Lysanov. Dimensionless absorption coefficient based on APL-UW Technical Report 9407.\n\n\n\n\n\n\n\n\n\nsurface_reflection_coef(windspeed, frequency, Œ∏)\nCompute surface reflection coefficient, given:\n\nwindspeed in m/s\nfrequency in Hz\nangle of incidence Œ∏ (angle to the surface normal)\n\nImplementation based on the APL-UW Technical Report 9407 II-21.\n\n\n\n\n\n\n\n\n\nbubble_resonance(radius, depth=0; Œ≥=1.4, p‚ÇÄ=1.013e5, œÅ=1022.72, g=9.80665)\nCompute resonance frequency of a freely oscillating has bubble in water, given:\n\nbubble radius in meters\ndepth of bubble in water in meters\ngas ratio of specific heats ‚ÄòŒ≥‚Äô\natmospheric pressure ‚Äòp‚ÇÄ‚Äô in Pa\ndensity of water ‚ÄòœÅ‚Äô in kg/m¬≥\nacceleration due to gravity ‚Äòg‚Äô in m/s¬≤\n\nThis ignores surface-tension, thermal, viscous and acoustic damping effects, and the pressure-volume relationship is taken to be adiabatic. Implementation based on Medwin & Clay (1998).\n\n\n\n\n\n\n\n\n\ndoppler(speed, frequency)\ndoppler(speed, frequency, soundspeed)\nCompute Doppler frequency, given relative speed between transmitter and receiver in m/s. soundspeed is the nominal sound speed in water.",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Underwater acoustics"
    ]
  },
  {
    "objectID": "quickstart.html",
    "href": "quickstart.html",
    "title": "Propagation & channel modeling",
    "section": "",
    "text": "Quickstart guide",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "quickstart.html#propagation-modeling",
    "href": "quickstart.html#propagation-modeling",
    "title": "Propagation & channel modeling",
    "section": "Propagation modeling",
    "text": "Propagation modeling\nLet‚Äôs get started:\n\nusing UnderwaterAcoustics\nusing Plots\n\n\nCreating an environmental description\nWe typically start with an environmental description:\n\nenv = UnderwaterEnvironment()\n\nUnderwaterEnvironment(\n  bathymetry = 100.0, \n  altimetry = 0.0, \n  temperature = 27.0, \n  salinity = 35.0, \n  pH = 8.1, \n  soundspeed = 1538.9235842, \n  density = 1022.7198310217424, \n  seabed = RigidBoundary, \n  surface = PressureReleaseBoundary, \n)\n\n\nIf the defaults don‚Äôt suit our needs, we can customize the environment. For example, if we wanted an environment with 20 m water depth, sandy-clay seabed, and a smooth sound speed profile with 1500 m/s near the surface, 1490 m/s at 10 m depth, and 1520 m/s near the seabed, we could define:\n\nenv = UnderwaterEnvironment(\n  bathymetry = 20.0,\n  seabed = SandyClay,\n  soundspeed = SampledField([1500, 1490, 1520]; z=0:-10:-20, interp=:cubic)\n)\n\nUnderwaterEnvironment(\n  bathymetry = 20.0, \n  altimetry = 0.0, \n  temperature = 27.0, \n  salinity = 35.0, \n  pH = 8.1, \n  soundspeed = SampledField(z-varying, 3 samples), \n  density = 1022.7198310217424, \n  seabed = FluidBoundary(œÅ=1173.381, c=1504.9272, Œ¥=0.00242), \n  surface = PressureReleaseBoundary, \n)\n\n\nIf we have Plots.jl installed, we can use plot recipes to plot the environment or the sound speed profile. For example:\n\nplot(env.soundspeed)\n\n\n\n\nLet us construct a range-independent iso-velocity environment with water depth of 20 m:\n\nenv = UnderwaterEnvironment(bathymetry=20, seabed=SandyClay)\n\nUnderwaterEnvironment(\n  bathymetry = 20, \n  altimetry = 0.0, \n  temperature = 27.0, \n  salinity = 35.0, \n  pH = 8.1, \n  soundspeed = 1538.9235842, \n  density = 1022.7198310217424, \n  seabed = FluidBoundary(œÅ=1173.381, c=1504.9272, Œ¥=0.00242), \n  surface = PressureReleaseBoundary, \n)\n\n\n\n\nSelecting a propagation model\nOnce we have an environment, we need to select a propagation model. Since we have a range-independent iso-velocity environment, we can use the PekerisRayTracer:\n\npm = PekerisRayTracer(env)\n\nPekerisRayTracer(h=20, max_bounces=3)\n\n\n\n\n\n\n\n\nTip\n\n\n\nWe can get a list of all available propagation models by calling models().\n\n\n\n\nSetting up transmitters and receivers\nNext, we need a source and a receiver:\n\ntx = AcousticSource(0.0, -5.0, 1000.0)\n\nTX[1000.0 Hz, 0 dB](0.0, 0.0, -5.0)\n\n\n\nrx = AcousticReceiver(100.0, -10.0)\n\nRX(100.0, 0.0, -10.0)\n\n\nFor improved readability, positions can be specified as tuples or named tuples, and the API fully supports Unitful.jl:\n\ntx = AcousticSource((x=0u\"m\", z=-5u\"m\"), 1u\"kHz\")\n\nTX[1000 Hz, 0 dB](0.0, 0.0, -5.0)\n\n\n\nrx = AcousticReceiver(100u\"m\", -10u\"m\")\n\nRX(100.0, 0.0, -10.0)\n\n\n\n\n\n\n\n\nTip\n\n\n\n2-tuples are interpreted as (x, z) and 3-tuples as (x, y, z). The coordinate system has x and y axis in the horizontal plane, and z axis pointing upwards, with the nominal water surface being at 0 m. This means that all z coordinates in water are negative. If units are not specified, they are assumed to be S.I. units (meters for distances, Hz for frequency, etc).\n\n\nWe just defined an omnidirectional 1 kHz transmitter tx at a depth of 5 m at the origin, and an omnidirectional receiver rx at a range of 100 m and a depth of 10 m.\n\n\nRunning the model\nNow that we have an environment, a propagation model, a transmitter and a receiver, we can modeling. First, we ask for all ray arrivals (eigenrays) between the transmitter and receiver:\n\nrays = arrivals(pm, tx, rx)\n\n7-element Vector{UnderwaterAcoustics.RayArrival{Float64, Float64, Float64, Float64, Vector{@NamedTuple{x::Float64, y::Float64, z::Float64}}}}:\n ‚à† -2.9¬∞  0‚§í  0‚§ì ‚à†  2.9¬∞ |  65.06 ms | -40.0 dB œï   0.0¬∞‚Üù\n ‚à†  8.5¬∞  1‚§í  0‚§ì ‚à†  8.5¬∞ |  65.71 ms | -40.1 dB œï 180.0¬∞‚Üù\n ‚à†-14.0¬∞  0‚§í  1‚§ì ‚à†-14.0¬∞ |  66.98 ms | -62.6 dB œï 170.9¬∞‚Üù\n ‚à† 19.3¬∞  1‚§í  1‚§ì ‚à†-19.3¬∞ |  68.85 ms | -74.3 dB œï -23.4¬∞‚Üù\n ‚à†-24.2¬∞  1‚§í  1‚§ì ‚à† 24.2¬∞ |  71.26 ms | -80.4 dB œï-145.6¬∞‚Üù\n ‚à† 28.8¬∞  2‚§í  1‚§ì ‚à† 28.8¬∞ |  74.16 ms | -73.5 dB œï  10.8¬∞‚Üù\n ‚à†-33.0¬∞  1‚§í  2‚§ì ‚à†-33.0¬∞ |  77.50 ms | -100.7 dB œï-167.2¬∞‚Üù\n\n\nFor each eigenray, this shows us the launch angle, number of surface bounces, number of bottom bounces, arrival angle, travel time, transmission loss along that ray, and phase change. The last ‚Äú‚Üù‚Äù symbol indicates that the complete ray path is also available. We can plot the ray paths:\n\nplot(env; xlims=(-10,110))\nplot!(tx)\nplot!(rx)\nplot!(rays)\n\n\n\n\nThe red star is the transmitter and the blue circle is the receiver. The stronger eigenrays are shown in blue, while the weaker ones are shown in red.\nOften, we are interested in the arrival structure at a receiver. We generate an impulse response sampled at 48 kSa/s and plot it:\n\nplot(impulse_response(pm, tx, rx, 48000))\n\n\n\n\nThe first arrival is at about 1 ms, as the impulse response is generated with timing relative to the first arrival with a guard time of 1 ms. If we wanted timings relative to the transmission time, we can set keyword argument abstime to true:\n\nplot(impulse_response(pm, tx, rx, 48000; abstime=true))\n\n\n\n\nWe can also get the complex acoustic field or the transmission loss in dB:\n\nacoustic_field(pm, tx, rx)\n\n0.011324625487986332 + 0.013441467920062827im\n\n\n\ntransmission_loss(pm, tx, rx)\n\n35.101536894459066\n\n\nWe can also pass in arrays of receivers, if we want to compute transmission loss at many locations simultaneously. Some models are able to compute transmission loss on a Cartesian grid very efficiently. This is useful to plot transmission loss as a function of space.\nTo define a 1000√ó200 Cartesian grid with 0.1 m spacing and compute the transmission loss over the grid:\n\nrxs = AcousticReceiverGrid2D(1.0:0.1:100, -20:0.1:0)\nx = transmission_loss(pm, tx, rxs)\n\n991√ó201 Matrix{Float64}:\n 19.1283  19.2328  19.5428  19.8492  ‚Ä¶   8.82646  11.1099  16.4209  87.1227\n 19.1329  19.2373  19.5471  19.8536      8.87496  11.1689  16.4855  87.123\n 19.1381  19.2424  19.552   19.8586      8.92702  11.2323  16.5549  87.1233\n 19.1442  19.2483  19.5577  19.8643      8.9824   11.2997  16.6288  87.1237\n 19.151   19.255   19.5641  19.8709      9.04085  11.3708  16.7068  87.124\n 19.1587  19.2626  19.5715  19.8784  ‚Ä¶   9.10213  11.4454  16.7886  87.1244\n 19.1674  19.2712  19.5799  19.8869      9.16604  11.5232  16.8739  87.1248\n 19.1772  19.2809  19.5893  19.8965      9.23241  11.604   16.9625  87.1253\n 19.1882  19.2918  19.6     19.9073      9.30109  11.6875  17.0541  87.1258\n 19.2005  19.3039  19.6119  19.9194      9.37202  11.7737  17.1485  87.1263\n  ‚ãÆ                                  ‚ã±                               ‚ãÆ\n 37.3745  37.4387  37.4769  37.4921     57.8844   61.3578  67.2495  98.1624\n 37.4079  37.4741  37.5144  37.5317     57.9056   61.3788  67.2688  98.1837\n 37.4422  37.5104  37.5527  37.5722     57.9268   61.4001  67.2893  98.205\n 37.4774  37.5476  37.592   37.6136  ‚Ä¶  57.9481   61.4217  67.3109  98.2263\n 37.5134  37.5857  37.6321  37.6558     57.9693   61.4435  67.3336  98.2477\n 37.5504  37.6247  37.6732  37.6989     57.9903   61.4655  67.3573  98.269\n 37.5882  37.6646  37.7151  37.7428     58.0112   61.4877  67.3819  98.2904\n 37.6269  37.7053  37.7578  37.7876     58.0319   61.5099  67.4075  98.3118\n 37.6665  37.7469  37.8014  37.8332  ‚Ä¶  58.0524   61.5322  67.4338  98.3333\n\n\n\nplot(env; xlims=(0,100))\nplot!(rxs, x)",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "quickstart.html#channel-modeling",
    "href": "quickstart.html#channel-modeling",
    "title": "Propagation & channel modeling",
    "section": "Channel modeling",
    "text": "Channel modeling\n\nSimulating a transmission\nOnce we have a propagation model, we can setup a channel simulation. Let‚Äôs say we had a 10 kHz source transmitting at a source level of 170 dB re 1 ¬µPa @ 1m and we wanted to run our simulations at 192 kSa/s:\n\ntx = AcousticSource((x=0u\"m\", z=-5u\"m\"), 10u\"kHz\"; spl=170)\nch = channel(pm, tx, rx, 192000)\n\nSampledPassbandChannel(1√ó1, 192000.0 Hz)\n\n\nThis channel accepts one input acoustic channel and yields one output acoustic channel. To transmit a signal through the channel, we create a windowed pulse using SignalAnalysis.jl and transmit() it through the channel ch:\n\nusing SignalAnalysis\n\nx = cw(10000, 0.001, 192000; window=(tukey, 0.5)) |&gt; real\ny = transmit(ch, x)\n\nplot(\n  plot(x; xlims=(0,5)),\n  plot(y; xlims=(0,5));\n  layout=(2,1)\n)\n\n\n\n\nThe received signal is scaled to be in ¬µPa, assuming the source level of the transmitter was specified in dB re 1 ¬µPa @ 1 m. We can clearly see the multipath arrivals in the received signal. Had we specified keyword argument abstime = true, we would have also seen the signal delayed by 65 ms.\n\n\nAdding noise\nWe can also simulate channels with noise. For example, if we wanted red Gaussian noise with standard deviation œÉ = 0.5 Pa, we can specify that when generating the channel:\n\nch = channel(pm, tx, rx, 192000; noise=RedGaussianNoise(0.5e6))\ny = transmit(ch, x)\n\nplot(\n  plot(x; xlims=(0,5)),\n  plot(y; xlims=(0,5));\n  layout=(2,1)\n)\n\n\n\n\nWe can see the noise in the timeseries. We can see the 1/f¬≤ variation (red Gaussian noise) in the power spectral density superimposed on the 10 kHz peak from the transmitted pulse:\n\npsd(y)",
    "crumbs": [
      "<b>UnderwaterAcoustics.jl</b>",
      "Propagation & channel modeling"
    ]
  },
  {
    "objectID": "modes.html",
    "href": "modes.html",
    "title": "On modal models",
    "section": "",
    "text": "Modal acoustic propagation models decompose the acoustic field into a sum of normal modes, each of which propagates independently through the waveguide. In its basic form, the model assumes a range-independent environment, where the sound speed, density, and seabed properties are constant with respect to range. The environment can be complicated in depth though, modeling variation of sound speed and density with depth, as well as multilayered elastic seabeds supporting shear waves and frequency-dependent absorption. Extensions to these models (e.g., adiabatic modes, coupled modes, etc.) can deal with range-dependent environments by modeling the interaction between modes at different ranges. Modal models are narrowband and computationally most suited to low frequency modeling. At high frequencies, the number of modes required to accurately represent the acoustic field increases significantly, leading to higher computational costs and potential numerical challenges.\n\n\n\n\n\nConsider a waveguide with the top boundary at \\(z=0\\) and the bottom boundary at \\(z=-D\\). To keep things simple, we first consider a homogenous seabed modeled as a bottom halfspace below \\(z=-D\\), and air as a top halfspace above \\(z=0\\). The acoustic pressure field in the waveguide due to a source of frequency \\(f\\) located at \\((r=0, z=z_s)\\) can be modeled as: \\[\np(r,z,t) \\propto \\sum_{m=1}^{\\infty} \\psi_m(z_s)\\psi_m(z)H_0(k_{rm}r)e^{i\\omega t},\n\\] where \\(\\omega = 2\\pi f\\) and \\(H_0(\\cdot)\\) is the Hankel function. The function \\(\\psi_m(z)\\) is a modal function that describes the vertical structure of the acoustic field in the waveguide, and \\(k_{rm}\\) is the radial wavenumber for mode \\(m\\). Each mode is normalized such that: \\[\n\\int_{-D}^{0} \\psi^2_m(z) \\; dz = 1.\n\\] We select a scaling factor to ensure transmission loss agrees with the convention used in (Jensen et al. 2011, sec. 5.2.1). Further, suppressing the time variability and replacing the Hankel function \\(H_0(\\cdot)\\) by its asymptotic approximation, we can write the pressure field as: \\[\np(r,z) \\approx \\sqrt\\frac{2\\pi}{r}e^{-i\\pi/4}\\sum_{m=1}^{\\infty} \\psi_m(z_s)\\psi_m(z)\\frac{e^{-ik_{rm}r}}{\\sqrt{k_{rm}}},\n\\] where \\(k_0\\) is the wavenumber at the source.\nThe radial wavenumber \\(k_{rm}\\) and the shape of the mode \\(\\psi_m(z)\\) are obtained by solving the following Sturm-Liouville eigenvalue problem with boundary conditions determined by the top and bottom halfspace properties: \\[\n\\rho(z)\\frac{d}{dz}\\left[\\frac{1}{\\rho(z)}\\psi^\\prime_m(z)\\right] + \\left[\\frac{\\omega^2}{c^2(z)}-k_{rm}^2\\right]\\psi_m(z) = 0,\n\\] where \\(\\psi^\\prime_m \\equiv d\\psi_m/dz\\).\nSince the acoustic impedance of air is much lower than that of water, the boundary condition at the air-water interface can be simplified to a pressure release boundary, i.e., \\(\\psi_m(0) = 0\\). The boundary conditions at the water-sediment interface depend on the sediment properties.\n\n\n\n\n\nFor a hard boundary at the sediment interface, we impose a no-penetration condition, which leads to the following boundary condition: \\[\n\\psi^\\prime_m(-D) = 0.\n\\] In case of an isovelocity channel with constant sound speed \\(c(z) = c\\) and density \\(\\rho(z) = \\rho\\), the problem simplifies significantly and has an analytical solution1: \\[\n\\psi_m(z) = \\sqrt\\frac{2}{D}\\sin(-k_{zm}z),\n\\] where the vertical wavenumber \\(k_{zm}\\) is given by: \\[\nk_{zm} = \\left(m - \\frac{1}{2}\\right)\\frac{\\pi}{D},\n\\] and the radial wavenumber \\(k_{rm}\\) is given by: \\[\nk_{rm} = \\sqrt{\\frac{\\omega^2}{c^2}-k_{zm}^2}.\n\\] When \\(k_{zm} \\le \\omega/c\\), \\(k_{rm}\\) is real and corresponds to propagating modes. When \\(k_{zm} &gt; \\omega/c\\), \\(k_{rm}\\) becomes imaginary, indicating evanescent modes that decay with range.\n\n\n\n\n\n\nNote\n\n\n\nThe PekerisModeSolver does not compute evanescent modes, as they do not contribute significantly to the acoustic field at long ranges. However, it returns wavenumbers with an imaginary component to account for frequency-dependent absorption in the water.\n\n\n\n\n\nAt long ranges, many seabeds behave like soft boundaries, and we can impose a pressure release condition at the sediment interface: \\(\\psi_m(-D) = 0\\). The analytical solution to the modal problem is then the same as the hard boundary case, except: \\[\nk_{zm} = \\frac{m\\pi}{D}.\n\\]\n\n\n\nIn the case of a fluid halfspace (e.g., water overlying a sediment layer that does not support shear waves), the sediment boundary conditions is: \\[\n\\rho_b\\psi^\\prime_m(-D) + \\rho\\sqrt{k_{rm}^2 - \\left(\\frac{\\omega}{c_b}\\right)^2}\\psi_m(-D) = 0,\n\\] where \\(\\rho_b\\) is the density of the sediment and \\(c_b\\) is the sound speed in the sediment. The modal function for this case is the same as the hard boundary case, but an analytical expression for \\(k_{zm}\\) is not available. Instead, \\(k_{zm}\\) is obtained numerically by solving the above boundary condition equation.\nFluid halfspace absorption can be modeled using a complex sound speed. However, this adds complexity to the root finding process as a complex domain numerical root finder becomes necessary.\n\n\n\n\n\n\nNote\n\n\n\nThe PekerisModeSolver does not support fluid halfspace absorption and ignores the Œ¥ parameter in the seabed definition. The Kraken model supports absorption in the fluid halfspaces.\n\n\n\n\n\n\n\n\n\n\n\nWork in progress\n\n\n\nTODO\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe PekerisModeSolver currently does not support acousto-elastic halfspaces. The Kraken model supports acousto-elastic halfspaces.\n\n\n\n\n\nThe treatment for multilayered sediment uses the same boundary conditions as the single-layer cases, but the boundary conditions are applied at each interface between layers. The formulation is not detailed here, but the approach is fairly straightforward in formulating a numerical recipe.\n\n\n\n\n\n\nNote\n\n\n\nThe PekerisModeSolver does not support multilayered sediment seabed. The Kraken model supports multilayered sediment.\n\n\n\n\n\n\nSolving the modal equation with a depth-dependent sound speed requires a numerical solver, as no analytical solution exists in a general case. The approach is straightforward in principle.\n\n\n\n\n\n\nNote\n\n\n\nThe PekerisModeSolver only supports iso-velocity environments. The Kraken model supports arbitrary sound speed profiles.\n\n\n\n\n\nThe group velocity of the modes can be obtained from the dispersion relation. For a given mode \\(m\\), the group velocity is defined as: \\[\nv_g(m) = \\frac{d\\omega}{dk_{rm}}.\n\\]\n\n\n\nSeveral approaches exist to extending the modal models for range dependent environments. In all the approaches, we compute the mode shapes and wavenumbers at discrete ranges from the source to the receiver, taking into account the varying environmental parameters. In order to compute the acoustic field, the modes excitation at the source is first estimated, and the modal excitation is propagated to the next range bin. The procedure continues iteratively, updating the modal excitation at each step until we reach the intended receiver range. The acoustic field at that range is then computed using the mode excitation at that range. The different approaches differ in how the modal excitation is transferred from one range bin to the next.\n\n\nThe simplest approach to transferring excitation from one range bin to the next is to assume that the excitation of a mode remains confined to the same mode in the next bin. Using this approach, we get a simple expression for the acoustic field: \\[\np(r,z) \\approx \\sqrt{2\\pi}e^{-i\\pi/4}\\sum_{m=1}^{\\infty} \\psi_m(0,z_s)\\psi_m(r,z)\\frac{e^{-i\\int_0^r k_{rm}dr}}{\\sqrt{\\int_0^r k_{rm}dr}}.\n\\]",
    "crumbs": [
      "<b>Notes</b>",
      "On modal models"
    ]
  },
  {
    "objectID": "modes.html#introduction",
    "href": "modes.html#introduction",
    "title": "On modal models",
    "section": "",
    "text": "Modal acoustic propagation models decompose the acoustic field into a sum of normal modes, each of which propagates independently through the waveguide. In its basic form, the model assumes a range-independent environment, where the sound speed, density, and seabed properties are constant with respect to range. The environment can be complicated in depth though, modeling variation of sound speed and density with depth, as well as multilayered elastic seabeds supporting shear waves and frequency-dependent absorption. Extensions to these models (e.g., adiabatic modes, coupled modes, etc.) can deal with range-dependent environments by modeling the interaction between modes at different ranges. Modal models are narrowband and computationally most suited to low frequency modeling. At high frequencies, the number of modes required to accurately represent the acoustic field increases significantly, leading to higher computational costs and potential numerical challenges.",
    "crumbs": [
      "<b>Notes</b>",
      "On modal models"
    ]
  },
  {
    "objectID": "modes.html#theory",
    "href": "modes.html#theory",
    "title": "On modal models",
    "section": "",
    "text": "Consider a waveguide with the top boundary at \\(z=0\\) and the bottom boundary at \\(z=-D\\). To keep things simple, we first consider a homogenous seabed modeled as a bottom halfspace below \\(z=-D\\), and air as a top halfspace above \\(z=0\\). The acoustic pressure field in the waveguide due to a source of frequency \\(f\\) located at \\((r=0, z=z_s)\\) can be modeled as: \\[\np(r,z,t) \\propto \\sum_{m=1}^{\\infty} \\psi_m(z_s)\\psi_m(z)H_0(k_{rm}r)e^{i\\omega t},\n\\] where \\(\\omega = 2\\pi f\\) and \\(H_0(\\cdot)\\) is the Hankel function. The function \\(\\psi_m(z)\\) is a modal function that describes the vertical structure of the acoustic field in the waveguide, and \\(k_{rm}\\) is the radial wavenumber for mode \\(m\\). Each mode is normalized such that: \\[\n\\int_{-D}^{0} \\psi^2_m(z) \\; dz = 1.\n\\] We select a scaling factor to ensure transmission loss agrees with the convention used in (Jensen et al. 2011, sec. 5.2.1). Further, suppressing the time variability and replacing the Hankel function \\(H_0(\\cdot)\\) by its asymptotic approximation, we can write the pressure field as: \\[\np(r,z) \\approx \\sqrt\\frac{2\\pi}{r}e^{-i\\pi/4}\\sum_{m=1}^{\\infty} \\psi_m(z_s)\\psi_m(z)\\frac{e^{-ik_{rm}r}}{\\sqrt{k_{rm}}},\n\\] where \\(k_0\\) is the wavenumber at the source.\nThe radial wavenumber \\(k_{rm}\\) and the shape of the mode \\(\\psi_m(z)\\) are obtained by solving the following Sturm-Liouville eigenvalue problem with boundary conditions determined by the top and bottom halfspace properties: \\[\n\\rho(z)\\frac{d}{dz}\\left[\\frac{1}{\\rho(z)}\\psi^\\prime_m(z)\\right] + \\left[\\frac{\\omega^2}{c^2(z)}-k_{rm}^2\\right]\\psi_m(z) = 0,\n\\] where \\(\\psi^\\prime_m \\equiv d\\psi_m/dz\\).\nSince the acoustic impedance of air is much lower than that of water, the boundary condition at the air-water interface can be simplified to a pressure release boundary, i.e., \\(\\psi_m(0) = 0\\). The boundary conditions at the water-sediment interface depend on the sediment properties.\n\n\n\n\n\nFor a hard boundary at the sediment interface, we impose a no-penetration condition, which leads to the following boundary condition: \\[\n\\psi^\\prime_m(-D) = 0.\n\\] In case of an isovelocity channel with constant sound speed \\(c(z) = c\\) and density \\(\\rho(z) = \\rho\\), the problem simplifies significantly and has an analytical solution1: \\[\n\\psi_m(z) = \\sqrt\\frac{2}{D}\\sin(-k_{zm}z),\n\\] where the vertical wavenumber \\(k_{zm}\\) is given by: \\[\nk_{zm} = \\left(m - \\frac{1}{2}\\right)\\frac{\\pi}{D},\n\\] and the radial wavenumber \\(k_{rm}\\) is given by: \\[\nk_{rm} = \\sqrt{\\frac{\\omega^2}{c^2}-k_{zm}^2}.\n\\] When \\(k_{zm} \\le \\omega/c\\), \\(k_{rm}\\) is real and corresponds to propagating modes. When \\(k_{zm} &gt; \\omega/c\\), \\(k_{rm}\\) becomes imaginary, indicating evanescent modes that decay with range.\n\n\n\n\n\n\nNote\n\n\n\nThe PekerisModeSolver does not compute evanescent modes, as they do not contribute significantly to the acoustic field at long ranges. However, it returns wavenumbers with an imaginary component to account for frequency-dependent absorption in the water.\n\n\n\n\n\nAt long ranges, many seabeds behave like soft boundaries, and we can impose a pressure release condition at the sediment interface: \\(\\psi_m(-D) = 0\\). The analytical solution to the modal problem is then the same as the hard boundary case, except: \\[\nk_{zm} = \\frac{m\\pi}{D}.\n\\]\n\n\n\nIn the case of a fluid halfspace (e.g., water overlying a sediment layer that does not support shear waves), the sediment boundary conditions is: \\[\n\\rho_b\\psi^\\prime_m(-D) + \\rho\\sqrt{k_{rm}^2 - \\left(\\frac{\\omega}{c_b}\\right)^2}\\psi_m(-D) = 0,\n\\] where \\(\\rho_b\\) is the density of the sediment and \\(c_b\\) is the sound speed in the sediment. The modal function for this case is the same as the hard boundary case, but an analytical expression for \\(k_{zm}\\) is not available. Instead, \\(k_{zm}\\) is obtained numerically by solving the above boundary condition equation.\nFluid halfspace absorption can be modeled using a complex sound speed. However, this adds complexity to the root finding process as a complex domain numerical root finder becomes necessary.\n\n\n\n\n\n\nNote\n\n\n\nThe PekerisModeSolver does not support fluid halfspace absorption and ignores the Œ¥ parameter in the seabed definition. The Kraken model supports absorption in the fluid halfspaces.\n\n\n\n\n\n\n\n\n\n\n\nWork in progress\n\n\n\nTODO\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe PekerisModeSolver currently does not support acousto-elastic halfspaces. The Kraken model supports acousto-elastic halfspaces.\n\n\n\n\n\nThe treatment for multilayered sediment uses the same boundary conditions as the single-layer cases, but the boundary conditions are applied at each interface between layers. The formulation is not detailed here, but the approach is fairly straightforward in formulating a numerical recipe.\n\n\n\n\n\n\nNote\n\n\n\nThe PekerisModeSolver does not support multilayered sediment seabed. The Kraken model supports multilayered sediment.\n\n\n\n\n\n\nSolving the modal equation with a depth-dependent sound speed requires a numerical solver, as no analytical solution exists in a general case. The approach is straightforward in principle.\n\n\n\n\n\n\nNote\n\n\n\nThe PekerisModeSolver only supports iso-velocity environments. The Kraken model supports arbitrary sound speed profiles.\n\n\n\n\n\nThe group velocity of the modes can be obtained from the dispersion relation. For a given mode \\(m\\), the group velocity is defined as: \\[\nv_g(m) = \\frac{d\\omega}{dk_{rm}}.\n\\]\n\n\n\nSeveral approaches exist to extending the modal models for range dependent environments. In all the approaches, we compute the mode shapes and wavenumbers at discrete ranges from the source to the receiver, taking into account the varying environmental parameters. In order to compute the acoustic field, the modes excitation at the source is first estimated, and the modal excitation is propagated to the next range bin. The procedure continues iteratively, updating the modal excitation at each step until we reach the intended receiver range. The acoustic field at that range is then computed using the mode excitation at that range. The different approaches differ in how the modal excitation is transferred from one range bin to the next.\n\n\nThe simplest approach to transferring excitation from one range bin to the next is to assume that the excitation of a mode remains confined to the same mode in the next bin. Using this approach, we get a simple expression for the acoustic field: \\[\np(r,z) \\approx \\sqrt{2\\pi}e^{-i\\pi/4}\\sum_{m=1}^{\\infty} \\psi_m(0,z_s)\\psi_m(r,z)\\frac{e^{-i\\int_0^r k_{rm}dr}}{\\sqrt{\\int_0^r k_{rm}dr}}.\n\\]",
    "crumbs": [
      "<b>Notes</b>",
      "On modal models"
    ]
  },
  {
    "objectID": "modes.html#footnotes",
    "href": "modes.html#footnotes",
    "title": "On modal models",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWhile \\(\\sin(k_{zm}z)\\) could also be a solution, we choose \\(\\sin(-k_{zm}z)\\) to get modal functions consistent with literature that uses \\(z\\) as depth (positive downwards).‚Ü©Ô∏é",
    "crumbs": [
      "<b>Notes</b>",
      "On modal models"
    ]
  }
]