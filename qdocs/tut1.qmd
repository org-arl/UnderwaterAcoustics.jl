---
title: "UComms 2020 webinar"
engine: julia
---

::: {.callout-note}
This tutorial is adapted from the examples presented in:<br>

- Mandar Chitre, "[Underwater Acoustics in the age of differentiable and probabilistic programming](https://www.facebook.com/watch/live/?v=2473971036238315)", UComms 2020 webinar, 3 December 2020.
:::

## Differentiable modeling
### Problem statement

Let us consider a scenario where a drifting probe acoustically transmits its sensor data periodically to a static receiver. The initial position of the sensor is perfectly known, and so is the environment. But the path of the sensor as it drifts is not known, but we'd like to get an estimate of it from the received acoustic signal. Due to the high data rate requirements, the receiver uses an equalization technique that requires an accurate estimate of the channel impulse response. We want to generate that using a propagation model and an accurate estimate of the location of the probe.

The environment is an iso-velocity channel with a constant depth of 20 m and known seabed parameters (density `Ï` = 1500 kg/mÂ³, sound speed `c` = 1850 m/s, and attenuation `Î´` = 0.001). The probe uses a 1-2 kHz band for data transmission, and includes 101 pilots at 10 Hz spacing to aid with channel estimation. The transmission loss can be accurately measured at those pilot frequencies, since the transmit source level is assumed to be known, but phase information is assumed to be unavailable at each pilot.

```{julia}
#| echo: false
using UnderwaterAcoustics
using Plots
default(size=(600, 400))
plot(UnderwaterEnvironment(bathymetry = 20.0); xlims=(-10, 150))
scatter!([(0, -5)]; markersize=4, color=:blue)
scatter!([(100, -6)]; markersize=4, marker=:star, color=:red)
plot!([100, 140], [-6, -6.8])
annotate!(0, -4, text("RX", 10, :blue))
annotate!(100, -5, text("TX (1-2 kHz)", 10, :red))
annotate!(110, -7, text("drift path", 10, :black))
```

### Dataset

To illustrate the idea, we generate a 60-transmission dataset with a linearly drifting path for the transmitter. Since we have an range-independent iso-velocity environment, we can use the `PekerisRayTracer` (otherwise we could use the `RaySolver`):

```{julia}
#| output: false
using UnderwaterAcoustics
using DataFrames

function ð’´((r, d, f, Ï, c, Î´))
  env = UnderwaterEnvironment(
    bathymetry = 20.0,
    seabed = FluidBoundary(Ï, c, Î´)
  )
  tx = AcousticSource(0.0, -5.0, f)
  rx = AcousticReceiver(r, -d)
  pm = PekerisRayTracer(env)
  transmission_loss(pm, tx, rx)
end

data = DataFrame([(
    range=100.0 + 0.5t,
    depth=6.0 + 0.01t,
    pilots=[ð’´([100.0 + 0.5t, 6.0 + 0.01t, f, 1500.0, 1850.0, 0.001]) for f âˆˆ 1000.0:10.0:2000.0]
  ) for t âˆˆ 0.0:1.0:59.0])
```

### Gradient descent

In order to recover the drift path of the probe, we build a simple error model for the measured pilots. We initialize the model with the known starting location of the probe, and track the probe by minimizing the error through gradient descent.

Since our propagation model is differentiable, the gradient of the error can be automatically computed during the optimization using [`ForwardDiff.jl`](https://github.com/JuliaDiff/ForwardDiff.jl).

```{julia}
#| output: false
using ForwardDiff

# channel model for pilots
pilots(r, d) = [ð’´([r, d, f, 1500.0, 1850.0, 0.001]) for f âˆˆ 1000.0:10.0:2000.0]

# gradient descent optimization
function chparams(data)
  history = []
  Î¸ = [100.0, 6.0]    # known initial location
  Î· = [1e-4, 1e-6]    # learning rate
  for row âˆˆ eachrow(data)
    err(Î¸) = sum(abs2, pilots(Î¸[1], Î¸[2]) .- row.pilots)  # error model
    for i âˆˆ 1:100      # iterations of simple gradient descent
      Î¸ .-=  Î· .* ForwardDiff.gradient(err, Î¸)
    end
    push!(history, (range=Î¸[1], depth=Î¸[2]))
  end
  DataFrame(history)
end

p = chparams(data)
```

Now that we have a path estimate, let's check it against the ground truth:

```{julia}
using Plots

plot(data.range, -data.depth; linewidth=2, xlabel="Range (m)", ylabel="Depth (m)", label="Ground truth")
scatter!(p.range, -p.depth; markersize=2, label="Estimated")
```

We have a pretty good match!

### Impulse response estimation

Now we can generate the impulse response for each of the 60 received data packets:

```{julia}
# compute impulse response
function iresp(r, d)
  env = UnderwaterEnvironment(
    bathymetry = 20.0,
    seabed = FluidBoundary(1500.0, 1850.0, 0.001)
  )
  tx = AcousticSource(0.0, -5.0, 1500.0)
  rx = AcousticReceiver(r, -d)
  pm = PekerisRayTracer(env)
  impulse_response(pm, tx, rx, 8000)[1:72]
end

ir = hcat([iresp(row.range, row.depth) for row âˆˆ eachrow(p)]...)'
heatmap(abs.(ir); xlabel="Delay (samples)", ylabel="Transmission #", yflip=true)
```

We see the impulse response evolve over time as the probe drifts. This can then be used for channel equalization and to recover the transmitted data!

## Probabilistic modeling

### Problem statement

Let us consider a geo-acoustic inversion problem where we have a static omnidirectional broadband acoustic source transmitting in a 5-7 kHz band. A single omnidirectional receiver picks up the signal at a fixed range, but profiles the water column, and therefore makes transmission loss measurements at various depths. We would like to estimate seabed parameters from these transmission loss measurements.

### Dataset

To illustrate this idea, let us generate a synthetic dataset for a known set of seabed parameters (density `Ï` = 1500 kg/mÂ³, relative soundspeed `c` = 1850 m/s, and attenuation `Î´` = 0.001). The environment is assumed to be an iso-velocity and with a constant depth of 20 m. The source is at a depth of 5 m. The receiver is at a range of 100 m from the source, and makes measurements at depths from 10 to 19 m in steps of 1 m.

```{julia}
#| echo: false
plot(UnderwaterEnvironment(bathymetry = 20.0); xlims=(-20, 120), ylims=(-22, 1))
scatter!([(0, -5)]; markersize=4, marker=:star, color=:red)
scatter!([(100, -d) for d âˆˆ 10:19]; markersize=4, color=:blue)
annotate!(0, -4, text("TX (5-7 kHz)", 10, :red))
annotate!(100, -9, text("RX", 10, :blue))
annotate!(50, -21, text("Ï=1500, c=1850, Î´=0.001", 10, :brown))
```

Since we have an range-independent iso-velocity environment, we can use the `PekerisRayTracer` (otherwise we could use the `RaySolver`):

```{julia}
#| output: false
using UnderwaterAcoustics
using DataFrames

function ð’´(Î¸)
  r, d, f, Ï, c, Î´ = Î¸
  env = UnderwaterEnvironment(
    bathymetry = 20.0,
    seabed = FluidBoundary(Ï, c, Î´)
  )
  tx = AcousticSource(0.0, -5.0, f)
  rx = AcousticReceiver(r, -d)
  pm = PekerisRayTracer(env)
  transmission_loss(pm, tx, rx)
end

data = DataFrame([
  (depth=d, frequency=f, xloss=ð’´([100.0, d, f, 1500.0, 1850.0, 0.001]))
  for d âˆˆ 10.0:1.0:19.0 for f âˆˆ 5000.0:100.0:7000.0
])
```

### Probabilistic model

We use some very loose uniform priors for `Ï`, `c` and `Î´`, and estimate the transmission loss using the same model ð’´, as used in the data generation, but without information on the actual seabed parameters. We assume that the measurements of transmission loss are normally distributed around the modeled transmission loss, with a covariance of 0.5 dB.

We define the probabilistic model as a [`Turing.jl`](https://github.com/TuringLang/Turing.jl) model:

```{julia}
#| output: false
using Turing

# depths d, frequencies f, transmission loss measurements x
@model function geoacoustic(d, f, x)
  Ïáµ£ ~ Uniform(1.0, 3.0)
  cáµ£ ~ Uniform(0.5, 3.5)
  Î´ ~ Uniform(0.0, 0.003)
  Î¼ = [ð’´([100.0, d[i], f[i], 1000Ïáµ£, 1500cáµ£, Î´]) for i âˆˆ 1:length(d)]
  x ~ MvNormal(Î¼, 0.5)
end
```

### Variational inference

Once we have the model defined, we can run Bayesian inference on it. We could either use MCMC methods from Turing, or variational inference. Since our model is differentiable, we choose to use the automatic differentiation variational inference (ADVI):

```{julia}
#| output: false
using Turing: Variational

q = vi(
  geoacoustic(data.depth, data.frequency, data.xloss),
  ADVI(100, 1000)
)
```

The returned `q` is a 3-dimensional posterior probability distribution over the parameters `Ï`, `c` and `Î´`. We can estimate the mean of the distribution by drawing random variates and taking the sample mean:

```{julia}
mean(rand(q, 10000); dims=2) .* [1000, 1500, 1]
```

We see that the estimated parameter means for `Ï`, `c` and `Î´` are quite close to the actual values used in generating the data.

We can also plot the conditional distributions of each parameter:

```{julia}
using StatsPlots

plot(Ï -> pdf(q, [Ï/1000, 1.2, 0.001]), 1300, 1700; xlabel="Ï")
```
```{julia}
plot(c -> pdf(q, [1.5, c/1500, 0.001]), 1650, 1950; xlabel="c")
```
```{julia}
plot(Î´ -> pdf(q, [1.5, 1.2, Î´]), 0.0, 0.003; xlabel="Î´")
```
